From 29e8fda3fc8736fe5054af134568030c0dd64455 Mon Sep 17 00:00:00 2001
From: Roman Shpuntov <roman.shpuntov@gmail.com>
Date: Tue, 4 Feb 2020 20:05:06 +0700
Subject: [PATCH 2/2] Add tvos device support

---
 gio/gtestdbus.c                  |  7 ++++++-
 gio/tests/gdbus-non-socket.c     |  8 ++++++--
 gio/tests/gschema-compile.c      |  2 ++
 gio/tests/socket.c               |  5 ++++-
 glib/gbacktrace.c                | 12 +++++++++++-
 glib/gspawn.c                    | 26 ++++++++++++++++++++++++++
 glib/gtestutils.c                |  6 ++++++
 glib/tests/spawn-multithreaded.c |  4 ++++
 meson.build                      |  4 ++++
 9 files changed, 69 insertions(+), 5 deletions(-)

Index: glib-2.84.4/gio/gtestdbus.c
===================================================================
--- glib-2.84.4.orig/gio/gtestdbus.c
+++ glib-2.84.4/gio/gtestdbus.c
@@ -239,6 +239,7 @@ watcher_init (void)
   static gsize started = 0;
   static GIOChannel *channel = NULL;
   int errsv;
+  pid_t child = -1;
 
   if (g_once_init_enter (&started))
     {
@@ -262,7 +263,11 @@ watcher_init (void)
       fflush (stdout);
       fflush (stderr);
 
-      switch (fork ())
+#if HAVE_FORK == 1
+      child = fork ();
+#endif
+
+      switch (child)
         {
         case -1:
           errsv = errno;
Index: glib-2.84.4/gio/tests/gdbus-non-socket.c
===================================================================
--- glib-2.84.4.orig/gio/tests/gdbus-non-socket.c
+++ glib-2.84.4/gio/tests/gdbus-non-socket.c
@@ -135,7 +135,7 @@ test_non_socket (void)
   GDBusConnection *connection;
   GError *error;
   gchar *guid;
-  pid_t first_child;
+  pid_t first_child = -1;
   GVariant *ret;
   const gchar *str;
   gboolean ok;
@@ -152,7 +152,11 @@ test_non_socket (void)
   g_assert (G_IS_INPUT_STREAM (g_io_stream_get_input_stream (streams[1])));
   g_assert (G_IS_OUTPUT_STREAM (g_io_stream_get_output_stream (streams[1])));
 
-  switch ((first_child = fork ()))
+#if HAVE_FORK == 1
+  first_child = fork ();
+#endif
+
+  switch (first_child)
     {
     case -1:
       g_assert_not_reached ();
Index: glib-2.84.4/gio/tests/gschema-compile.c
===================================================================
--- glib-2.84.4.orig/gio/tests/gschema-compile.c
+++ glib-2.84.4/gio/tests/gschema-compile.c
@@ -27,7 +27,9 @@ test_schema_do_compile (gpointer data)
   };
   gchar *envp[] = { NULL };
 
+#if HAVE_FORK == 1
   execve (argv[0], (char **) argv, envp);
+#endif
   g_assert_not_reached ();
 }
 
Index: glib-2.84.4/gio/tests/socket.c
===================================================================
--- glib-2.84.4.orig/gio/tests/socket.c
+++ glib-2.84.4/gio/tests/socket.c
@@ -1460,7 +1460,7 @@ test_unix_connection_ancillary_data (voi
   gint pv[2], sv[3];
   gint status, fd, len;
   char buffer[1024];
-  pid_t pid;
+  pid_t pid = -1;
 
   status = pipe (pv);
   g_assert_cmpint (status, ==, 0);
@@ -1468,7 +1468,10 @@ test_unix_connection_ancillary_data (voi
   status = socketpair (PF_UNIX, SOCK_STREAM, 0, sv);
   g_assert_cmpint (status, ==, 0);
 
+#if HAVE_FORK == 1
   pid = fork ();
+#endif
+
   g_assert_cmpint (pid, >=, 0);
 
   /* Child: close its copy of the write end of the pipe, receive it
Index: glib-2.84.4/glib/gbacktrace.c
===================================================================
--- glib-2.84.4.orig/glib/gbacktrace.c
+++ glib-2.84.4/glib/gbacktrace.c
@@ -249,7 +249,7 @@ void
 g_on_error_stack_trace (const gchar *prg_name)
 {
 #if defined(G_OS_UNIX)
-  pid_t pid;
+  pid_t pid = -1;
   gchar buf[16];
   gchar buf2[64];
   const gchar *args[5] = { DEBUGGER, NULL, NULL, NULL, NULL };
@@ -272,7 +272,10 @@ g_on_error_stack_trace (const gchar *prg
   args[2] = buf;
 #endif
 
+#if HAVE_FORK == 1
   pid = fork ();
+#endif
+
   if (pid == 0)
     {
       stack_trace (args);
@@ -397,9 +400,15 @@ stack_trace (const char * const *args)
       _exit (0);
     }
 
+#if HAVE_FORK == 1
   pid = fork ();
+#else
+  pid = -1;
+#endif
+
   if (pid == 0)
     {
+#if HAVE_FORK == 1
       /* Save stderr for printing failure below */
       int old_err = dup (2);
       if (old_err != -1)
@@ -427,6 +436,7 @@ stack_trace (const char * const *args)
         }
       perror ("exec " DEBUGGER " failed");
       _exit (0);
+#endif
     }
   else if (pid == (pid_t) -1)
     {
Index: glib-2.84.4/glib/gtestutils.c
===================================================================
--- glib-2.84.4.orig/glib/gtestutils.c
+++ glib-2.84.4/glib/gtestutils.c
@@ -3941,7 +3941,13 @@ g_test_trap_fork (guint64        usec_ti
       errsv = errno;
       g_error ("failed to create pipes to fork test program: %s", g_strerror (errsv));
     }
+
+#if HAVE_FORK == 1
   test_trap_last_pid = fork ();
+#else
+  test_trap_last_pid = -1;
+#endif
+
   errsv = errno;
   if (test_trap_last_pid < 0)
     g_error ("failed to fork test program: %s", g_strerror (errsv));
Index: glib-2.84.4/glib/tests/spawn-multithreaded.c
===================================================================
--- glib-2.84.4.orig/glib/tests/spawn-multithreaded.c
+++ glib-2.84.4/glib/tests/spawn-multithreaded.c
@@ -87,7 +87,11 @@ get_a_child (gint ttl)
 
   return pid;
 #else
+#if HAVE_FORK == 1
   pid = fork ();
+#else
+  pid = -1;
+#endif
   if (pid < 0)
     exit (1);
 
Index: glib-2.84.4/meson.build
===================================================================
--- glib-2.84.4.orig/meson.build
+++ glib-2.84.4/meson.build
@@ -2486,6 +2486,10 @@ main (void)
   exit (__getcmdline ());
 }'''
 
+if host_system != 'windows' and cc.has_function('fork', prefix : '#include <unistd.h>')
+  glib_conf.set('HAVE_FORK', 1)
+endif
+
 if cc_can_run
   rres = cc.run(cmdline_test_code, name : '/proc/self/cmdline')
   have_proc_self_cmdline = rres.compiled() and rres.returncode() == 0
Index: glib-2.84.4/glib/gspawn-posix.c
===================================================================
--- glib-2.84.4.orig/glib/gspawn-posix.c
+++ glib-2.84.4/glib/gspawn-posix.c
@@ -1474,8 +1474,10 @@ fork_exec (gboolean              interme
       if (source_fds_collide_with_pipe (&child_pid_report_pipe, source_fds, n_fds, error))
         goto cleanup_and_fail;
     }
-  
+
+#if HAVE_FORK == 1
   pid = fork ();
+#endif
 
   if (pid < 0)
     {
@@ -1528,7 +1530,11 @@ fork_exec (gboolean              interme
            */
           GPid grandchild_pid;
 
+#if HAVE_FORK == 1
           grandchild_pid = fork ();
+#else
+	  grandchild_pid = 1;
+#endif
 
           if (grandchild_pid < 0)
             {
@@ -1825,11 +1831,15 @@ script_execute (const gchar *file,
       --argc;
     }
 
+#if HAVE_FORK == 1
   /* Execute the shell. */
   if (envp)
     execve (argv_buffer[0], argv_buffer, envp);
   else
     execv (argv_buffer[0], argv_buffer);
+#else
+  return FALSE;
+#endif
 
   return TRUE;
 }
@@ -1865,6 +1875,7 @@ g_execute (const gchar  *file,
       return -1;
     }
 
+#if HAVE_FORK == 1
   if (search_path == NULL || strchr (file, '/') != NULL)
     {
       /* Don't search when it contains a slash. */
@@ -1983,6 +1994,9 @@ g_execute (const gchar  *file,
         errno = EACCES;
     }
 
+#else
+  errno = ENOSYS;
+#endif
   /* Return the error from the last attempt (probably ENOENT).  */
   return -1;
 }
