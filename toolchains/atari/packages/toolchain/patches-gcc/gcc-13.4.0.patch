diff --git a/config-ml.in b/config-ml.in
index 68854a4f16c..a626f1b2d70 100644
--- a/config-ml.in
+++ b/config-ml.in
@@ -346,6 +346,23 @@ m68*-*-*)
 	    esac
 	  done
 	fi
+	case "${host}" in
+	  *-*-mint*)
+	    case "${srcdir}" in
+	      */libgcc ) : ;;
+	      *)
+	        old_multidirs="${multidirs}"
+	        multidirs=""
+	        for x in ${old_multidirs}; do
+		  case "$x" in
+		    *mshort ) : ;;
+		    *) multidirs="${multidirs} ${x}" ;;
+		  esac
+		done
+		;;
+	    esac
+	    ;;
+	esac
 	;;
 mips*-*-*)
 	if [ x$enable_single_float = xno ]
diff --git a/config.guess b/config.guess
index 1972fda8eb0..31f4f2cc8c4 100755
--- a/config.guess
+++ b/config.guess
@@ -466,22 +466,22 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mintelf
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mintelf
 	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mintelf
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint"$UNAME_RELEASE"
+	echo m68k-milan-mintelf
 	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint"$UNAME_RELEASE"
+	echo m68k-hades-mintelf
 	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint"$UNAME_RELEASE"
+	echo m68k-unknown-mintelf
 	exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten"$UNAME_RELEASE"
diff --git a/config/picflag.m4 b/config/picflag.m4
index 0aefcf619bf..eec199987a2 100644
--- a/config/picflag.m4
+++ b/config/picflag.m4
@@ -27,6 +27,8 @@ case "${$2}" in
 	;;
     i[[34567]]86-*-mingw* | x86_64-*-mingw*)
 	;;
+    *-*-mint*)
+	;;
     i[[34567]]86-*-interix[[3-9]]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
 	# Instead, we relocate shared libraries at runtime.
diff --git a/gcc/common/config/m68k/m68k-common.cc b/gcc/common/config/m68k/m68k-common.cc
index fd2143950e1..340ab4ea363 100644
--- a/gcc/common/config/m68k/m68k-common.cc
+++ b/gcc/common/config/m68k/m68k-common.cc
@@ -75,4 +75,26 @@ m68k_handle_option (struct gcc_options *opts,
 #undef TARGET_HANDLE_OPTION
 #define TARGET_HANDLE_OPTION m68k_handle_option
 
+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */
+
+static enum unwind_info_type
+m68k_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)
+{
+#ifdef USING_ELFOS_H
+  /* Honor the --enable-sjlj-exceptions configure switch.  */
+#ifdef CONFIG_SJLJ_EXCEPTIONS
+  if (CONFIG_SJLJ_EXCEPTIONS)
+    return UI_SJLJ;
+#endif
+
+  if (DWARF2_UNWIND_INFO)
+    return UI_DWARF2;
+#endif
+
+  return UI_SJLJ;
+}
+
+#undef TARGET_EXCEPT_UNWIND_INFO
+#define TARGET_EXCEPT_UNWIND_INFO  m68k_except_unwind_info
+
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index ae332a88768..dddb0fb6f01 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2356,6 +2356,18 @@ m68k-*-linux*)			# Motorola m68k's running GNU/Linux
 	tm_defines="${tm_defines} MOTOROLA=1"
 	tmake_file="${tmake_file} m68k/t-floatlib m68k/t-linux m68k/t-mlibs"
 	;;
+m68k-*-mintelf*)
+	default_m68k_cpu=68000
+	default_cf_cpu=5475
+	tm_file="${tm_file} m68k/m68k-none.h elfos.h m68k/mint.h m68k/mint-stdint.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-mint m68k/t-mlibs"
+	gas=yes
+	gnu_ld=yes
+	if test "${enable_initfini_array}" != "no"; then
+		gcc_cv_initfini_array=yes
+	fi
+	;;
 m68k-*-rtems*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5206
diff --git a/gcc/config/m68k/m68k.cc b/gcc/config/m68k/m68k.cc
index 03db2b6a936..2e198f6e03f 100644
--- a/gcc/config/m68k/m68k.cc
+++ b/gcc/config/m68k/m68k.cc
@@ -712,6 +712,14 @@ m68k_option_override (void)
       else
 	m68k_sched_mac = MAC_NO;
     }
+
+  /*
+   * disable -fcombine-stack-adjustments for coldfire/mshort combination,
+   * which generates wrong CFI offsets.
+   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88160
+   */
+  if (PREFERRED_STACK_BOUNDARY > 16 && INT_TYPE_SIZE <= 16 && (write_symbols & DWARF2_DEBUG))
+    flag_combine_stack_adjustments = 0;
 }
 
 /* Implement TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE.  */
@@ -1020,6 +1028,40 @@ m68k_set_frame_related (rtx_insn *insn)
       RTX_FRAME_RELATED_P (XVECEXP (body, 0, i)) = 1;
 }
 
+#define IS_INTERRUPT(func_kind) (func_kind != m68k_fk_normal_function)
+
+int m68k_emit_stack_check(void)
+{
+  if (flag_stack_check == FULL_BUILTIN_STACK_CHECK &&
+        !IS_INTERRUPT(m68k_get_function_kind (current_function_decl)) &&
+        !DECL_NO_LIMIT_STACK(current_function_decl))
+  {
+        rtx_code_label *lab1;
+        rtx limit_mem;
+        rtx jump;
+
+        static rtx stack_limit_symbol;
+        static rtx stack_overflow_rtx;
+
+        if (stack_limit_symbol == 0)
+                stack_limit_symbol = gen_rtx_SYMBOL_REF (Pmode, "_StkLim");
+        if (stack_overflow_rtx == 0)
+                stack_overflow_rtx = gen_rtx_SYMBOL_REF (Pmode, "_StkOver");
+        lab1 = gen_label_rtx ();
+        limit_mem = gen_rtx_MEM (Pmode, stack_limit_symbol);
+        emit_cmp_and_jump_insns (limit_mem, stack_pointer_rtx, LTU, 0,
+                           Pmode, 1, lab1);
+        JUMP_LABEL (get_last_insn ()) = lab1;
+        jump = gen_rtx_SET(pc_rtx, stack_overflow_rtx);
+        emit_insn(jump);
+        emit_barrier ();
+        emit_label(lab1);
+        return true;
+  }
+  return false;
+}
+
+
 /* Emit RTL for the "prologue" define_expand.  */
 
 void
@@ -1036,7 +1078,7 @@ m68k_expand_prologue (void)
 
   /* If the stack limit is a symbol, we can check it here,
      before actually allocating the space.  */
-  if (crtl->limit_stack
+  if (crtl->limit_stack && !IS_INTERRUPT(m68k_get_function_kind (current_function_decl))
       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)
     {
       limit = plus_constant (Pmode, stack_limit_rtx, current_frame.size + 4);
@@ -1126,9 +1168,14 @@ m68k_expand_prologue (void)
 	}
     }
 
+#ifdef STACK_CHECK_ATARI
+  if (m68k_emit_stack_check())
+  {
+  } else
+#endif
   /* If the stack limit is not a symbol, check it here.
      This has the disadvantage that it may be too late...  */
-  if (crtl->limit_stack)
+  if (crtl->limit_stack && !IS_INTERRUPT(m68k_get_function_kind (current_function_decl)))
     {
       if (REG_P (stack_limit_rtx))
         emit_insn (gen_ctrapsi4 (gen_rtx_LTU (VOIDmode, stack_pointer_rtx,
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index 450c380359c..3b5f9f2916a 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -131,7 +131,10 @@ along with GCC; see the file COPYING3.  If not see
 	}								\
 									\
       if (TARGET_68881)							\
-	builtin_define ("__HAVE_68881__");				\
+	{								\
+	  builtin_define ("__HAVE_68881__");				\
+	  builtin_define ("__M68881__"); /* Non-standard */		\
+	}								\
 									\
       if (TARGET_COLDFIRE)						\
 	{								\
diff --git a/gcc/config/m68k/math-68881.h b/gcc/config/m68k/math-68881.h
index 6d9f8b2d4a1..9fad2950508 100644
--- a/gcc/config/m68k/math-68881.h
+++ b/gcc/config/m68k/math-68881.h
@@ -44,6 +44,16 @@
 
 #include <errno.h>
 
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+#ifdef __cplusplus
+# define __MATH_68881_INLINE inline
+#elif defined __GNUC_STDC_INLINE__
+# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
+#else
+# define __MATH_68881_INLINE extern __inline
+#endif
+
 #undef HUGE_VAL
 #ifdef __sun__
 /* The Sun assembler fails to handle the hex constant in the usual defn.  */
@@ -64,7 +74,7 @@
 })
 #endif
 
-__inline extern double
+__MATH_68881_INLINE double
 sin (double x)
 {
   double value;
@@ -75,7 +85,7 @@ sin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cos (double x)
 {
   double value;
@@ -86,7 +96,7 @@ cos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tan (double x)
 {
   double value;
@@ -97,7 +107,7 @@ tan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 asin (double x)
 {
   double value;
@@ -108,7 +118,7 @@ asin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 acos (double x)
 {
   double value;
@@ -119,7 +129,7 @@ acos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan (double x)
 {
   double value;
@@ -130,7 +140,7 @@ atan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan2 (double y, double x)
 {
   double pi, pi_over_2;
@@ -187,7 +197,7 @@ atan2 (double y, double x)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sinh (double x)
 {
   double value;
@@ -198,7 +208,7 @@ sinh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cosh (double x)
 {
   double value;
@@ -209,7 +219,7 @@ cosh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tanh (double x)
 {
   double value;
@@ -220,7 +230,7 @@ tanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atanh (double x)
 {
   double value;
@@ -231,7 +241,7 @@ atanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 exp (double x)
 {
   double value;
@@ -242,7 +252,7 @@ exp (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 expm1 (double x)
 {
   double value;
@@ -253,7 +263,7 @@ expm1 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log (double x)
 {
   double value;
@@ -264,7 +274,7 @@ log (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log1p (double x)
 {
   double value;
@@ -275,7 +285,7 @@ log1p (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log10 (double x)
 {
   double value;
@@ -286,7 +296,7 @@ log10 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sqrt (double x)
 {
   double value;
@@ -297,13 +307,13 @@ sqrt (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 hypot (double x, double y)
 {
   return sqrt (x*x + y*y);
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 pow (double x, double y)
 {
   if (x > 0)
@@ -352,7 +362,7 @@ pow (double x, double y)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fabs (double x)
 {
   double value;
@@ -363,7 +373,7 @@ fabs (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ceil (double x)
 {
   int rounding_mode, round_up;
@@ -385,7 +395,7 @@ ceil (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 floor (double x)
 {
   int rounding_mode, round_down;
@@ -408,7 +418,7 @@ floor (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 rint (double x)
 {
   int rounding_mode, round_nearest;
@@ -430,7 +440,7 @@ rint (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fmod (double x, double y)
 {
   double value;
@@ -442,7 +452,7 @@ fmod (double x, double y)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 drem (double x, double y)
 {
   double value;
@@ -454,19 +464,20 @@ drem (double x, double y)
   return value;
 }
 
-__inline extern double
-scalb (double x, int n)
+__MATH_68881_INLINE double
+scalb (double x, double n)
 {
   double value;
+  int exp = (int)(n);
 
   __asm ("fscale%.l %2,%0"
 	 : "=f" (value)
 	 : "0" (x),
-	   "dmi" (n));
+	   "dmi" (exp));
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 logb (double x)
 {
   double exponent;
@@ -477,7 +488,7 @@ logb (double x)
   return exponent;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ldexp (double x, int n)
 {
   double value;
@@ -489,7 +500,7 @@ ldexp (double x, int n)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 frexp (double x, int *exp)
 {
   double float_exponent;
@@ -514,7 +525,7 @@ frexp (double x, int *exp)
   return mantissa;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 modf (double x, double *ip)
 {
   double temp;
diff --git a/gcc/config/m68k/mint-stdint.h b/gcc/config/m68k/mint-stdint.h
new file mode 100644
index 00000000000..44dcfc2dea9
--- /dev/null
+++ b/gcc/config/m68k/mint-stdint.h
@@ -0,0 +1,50 @@
+/* Definitions for <stdint.h> types on systems using MiNT.
+   Copyright (C) 2009-2023 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE "int"
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE (TARGET_SHORT ? "int" : "short int")
+#define INT32_TYPE (TARGET_SHORT ? "long int" : "int")
+#define INT64_TYPE "long long int"
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE (TARGET_SHORT ? "unsigned int" : "short unsigned int")
+#define UINT32_TYPE (TARGET_SHORT ? "long unsigned int" : "unsigned int")
+#define UINT64_TYPE "long long unsigned int"
+
+#define INT_LEAST8_TYPE INT8_TYPE
+#define INT_LEAST16_TYPE INT16_TYPE
+#define INT_LEAST32_TYPE INT32_TYPE
+#define INT_LEAST64_TYPE INT64_TYPE
+#define UINT_LEAST8_TYPE UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE INT8_TYPE
+#define INT_FAST16_TYPE INT16_TYPE
+#define INT_FAST32_TYPE INT32_TYPE
+#define INT_FAST64_TYPE INT64_TYPE
+#define UINT_FAST8_TYPE UINT8_TYPE
+#define UINT_FAST16_TYPE UINT16_TYPE
+#define UINT_FAST32_TYPE UINT32_TYPE
+#define UINT_FAST64_TYPE UINT64_TYPE
+
+#define INTPTR_TYPE "long int"
+#define UINTPTR_TYPE "long unsigned int"
diff --git a/gcc/config/m68k/mint.h b/gcc/config/m68k/mint.h
new file mode 100644
index 00000000000..ad49661bec7
--- /dev/null
+++ b/gcc/config/m68k/mint.h
@@ -0,0 +1,223 @@
+/* Definitions of target machine for GCC for Atari ST TOS/MiNT.
+   Copyright (C) 1994-2023 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* The prefix for register names.  Note that REGISTER_NAMES
+   is supposed to include this prefix. Also note that this is NOT an
+   fprintf format string, it is a literal string */
+
+#undef REGISTER_PREFIX
+#define REGISTER_PREFIX "%"
+
+/* The prefix for local (compiler generated) labels.
+   These labels will not appear in the symbol table.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+/* The prefix to add to user-visible assembler symbols.  */
+
+#undef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
+
+/* How to start an assembler comment.  */
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "|"
+
+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to
+   keep switch tables in the text section.  */
+
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+/* Use the default action for outputting the case label.  */
+
+#undef ASM_OUTPUT_CASE_LABEL
+#define ASM_RETURN_CASE_JUMP				\
+  do {							\
+    if (TARGET_COLDFIRE)				\
+      {							\
+	if (ADDRESS_REG_P (operands[0]))		\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else if (TARGET_LONG_JUMP_TABLE_OFFSETS)	\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else						\
+	  return "ext%.l %0\n\tjmp %%pc@(2,%0:l)";	\
+      }							\
+    else if (TARGET_LONG_JUMP_TABLE_OFFSETS)		\
+      return "jmp %%pc@(2,%0:l)";			\
+    else						\
+      return "jmp %%pc@(2,%0:w)";			\
+  } while (0)
+
+/* As offset 2 is hardcoded in the jmp instruction above,
+   the ADDR_VEC must immediately follow the jmp instruction.
+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=112413  */
+
+#define ADDR_VEC_ALIGN(ADDR_VEC) 0
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+
+#undef ASM_OUTPUT_ALIGN
+#define ASM_OUTPUT_ALIGN(FILE,LOG)				\
+do {								\
+  if ((LOG) > 0)						\
+    fprintf ((FILE), "%s%u\n", ALIGN_ASM_OP, 1 << (LOG));	\
+} while (0)
+
+/* If defined, a C expression whose value is a string containing the
+   assembler operation to identify the following data as uninitialized global
+   data.  */
+
+#define BSS_SECTION_ASM_OP "\t.section\t.bss"
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* Disable -fpic and -fPIC since bsr.l _label@PLTPC
+   is unsupported by the assembler.  */
+
+#undef  SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (flag_pic && !TARGET_PCREL)					\
+      error ("%<-f%s%> is not supported on this target",		\
+	       (flag_pic > 1) ? "PIC" : "pic");				\
+} while (0)
+
+/* Define these to avoid dependence on meaning of `int'.  */
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 16
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE "long int"
+#undef  SIZE_TYPE
+#define SIZE_TYPE "long unsigned int"
+
+/* Don't default to pcc-struct-return, so that we can return small structures
+   and unions in registers, which is slightly more efficient.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#if HAVE_INITFINI_ARRAY_SUPPORT
+#define GCC_HAVE_INITFINI_ARRAY_SUPPORT builtin_define ("__GCC_HAVE_INITFINI_ARRAY_SUPPORT");
+#else
+#define GCC_HAVE_INITFINI_ARRAY_SUPPORT
+#endif
+
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__MINT__");		\
+      GCC_HAVE_INITFINI_ARRAY_SUPPORT \
+      builtin_define_std ("atarist");		\
+      builtin_assert ("machine=atari");		\
+      builtin_assert ("system=mint");		\
+    }						\
+  while (0)
+
+/* The following defines are nonstandard and are kept only for compatibility
+   with older versions of GCC for MiNT.  */
+
+#undef  CPP_SPEC
+#define CPP_SPEC					\
+  "%{m68000|mcpu=68000:-D__M68000__} "			\
+  "%{m68020|mcpu=68020:-D__M68020__} "			\
+  "%{m68030|mcpu=68030:-D__M68020__} "			\
+  "%{m68040|mcpu=68040:-D__M68020__} "			\
+  "%{m68060|mcpu=68060:-D__M68020__} "			\
+  "%{m68020-40|mcpu=68020-40:-D__M68020__} "		\
+  "%{m68020-60|mcpu=68020-60:-D__M68020__} "		\
+  "%{!m680*:%{!mc680*:%{!mcpu=680*:-D__M68000__}}} "	\
+  "%{mshort:-D__MSHORT__}"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "%{pg|p|profile:gcrt0.o%s;:crt0.o%s} crtbegin.o%s"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s"
+
+#undef  LIB_SPEC
+#define LIB_SPEC "-lc"
+
+/* The MiNTLib doesn't have support for .init and .fini sections yet.  */
+#undef INIT_SECTION_ASM_OP
+#undef FINI_SECTION_ASM_OP
+
+/* avoid pulling in the tm_clone support which we don't need */
+#define USE_TM_CLONE_REGISTRY 0
+
+/* Install the __sync libcalls.  */
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS  m68k_init_sync_libfuncs
+
+/* with fdlibm, most of the c99 functions are available, including sincos */
+#undef  TARGET_LIBC_HAS_FUNCTION
+#define TARGET_LIBC_HAS_FUNCTION bsd_libc_has_function
+
+/* Define how the m68k registers should be numbered for Dwarf output.
+   The numbering provided here should be compatible with the native
+   SVR4 debugger in the m68k/SVR4 reference port, where d0-d7
+   are 0-7, a0-a8 are 8-15, and fp0-fp7 are 16-23.  */
+
+#undef DEBUGGER_REGNO
+#define DEBUGGER_REGNO(REGNO) (REGNO)
+
+/* After initial relocation, exception handling tables are never written.  */
+#define EH_TABLES_CAN_BE_READ_ONLY 1
+
+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that
+   the rest of the DWARF 2 frame unwind support is also provided.
+   
+   All configurations that don't use elf must be explicit about not using
+   dwarf unwind information.
+
+   MiNT: DWARF 2 frame unwind is not supported by a.out-mint.
+*/
+#undef DWARF2_UNWIND_INFO
+/* If configured with --disable-sjlj-exceptions, use DWARF2
+   else default to SJLJ.  */
+#if defined(USING_ELFOS_H) && defined (CONFIG_SJLJ_EXCEPTIONS) && !CONFIG_SJLJ_EXCEPTIONS
+/* The logic of this #if must be kept synchronised with the logic
+   for selecting the tmake_eh_file fragment in libgcc/config.host.  */
+#define DWARF2_UNWIND_INFO 1
+#else
+#define DWARF2_UNWIND_INFO 0
+#endif
+
+#if DWARF2_UNWIND_INFO
+/* the default of DW_EH_PE_absptr creates relocations at odd addresses, which we cannot handle */
+#undef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)			   \
+  (flag_pic								   \
+   && !((TARGET_ID_SHARED_LIBRARY || TARGET_SEP_DATA)			   \
+	&& ((GLOBAL) || (CODE)))					   \
+   ? ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4 \
+   : DW_EH_PE_aligned)
+#endif
+
+#define STACK_CHECK_ATARI
+#define STACK_CHECK_BUILTIN 1
+int m68k_emit_stack_check(void);
diff --git a/gcc/config/m68k/t-mint b/gcc/config/m68k/t-mint
new file mode 100644
index 00000000000..a126d8e0682
--- /dev/null
+++ b/gcc/config/m68k/t-mint
@@ -0,0 +1,5 @@
+M68K_MLIB_CPU += && ((CPU ~ "^m68000") || (CPU ~ "^m68020") || (CPU ~ "^mcf5475"))
+
+M68K_MLIB_OPTIONS += mshort
+
+M68K_MLIB_DIRNAMES += mshort
diff --git a/gcc/config/m68k/t-mlibs b/gcc/config/m68k/t-mlibs
index cf0ceac63f5..243402f2c84 100644
--- a/gcc/config/m68k/t-mlibs
+++ b/gcc/config/m68k/t-mlibs
@@ -45,9 +45,10 @@ ifeq ($(filter m$(M68K_MLIB_DEFAULT),$(M68K_MLIB_CPUS)),)
 $(error Error default cpu '$(target_cpu_default)' is not in multilib set '$(M68K_MLIB_CPUS)')
 endif
 
-MULTILIB_DIRNAMES := $(filter-out m$(M68K_MLIB_DEFAULT),$(M68K_MLIB_CPUS))
+MULTILIB_DIRNAMES := $(subst m68020,m68020-60,$(filter-out m$(M68K_MLIB_DEFAULT),$(M68K_MLIB_CPUS)))
 MULTILIB_OPTIONS := $(shell echo $(MULTILIB_DIRNAMES:m%=mcpu=%) \
-		      | sed -e 's| |/|g' )
+		      | sed -e 's| |/|g' \
+		      | sed -e 's|cpu=68020-60|68020-60|g' )
 
 # Add subtarget specific options & dirs.
 MULTILIB_DIRNAMES += $(M68K_MLIB_DIRNAMES)
@@ -58,17 +59,44 @@ MULTILIB_MATCHES :=
 ifneq ($(M68K_ARCH),cf)
 # Map -march=* options to the representative -mcpu=* option.
 MULTILIB_MATCHES += mcpu?68000=march?68000 \
-		    mcpu?68020=march?68020 \
-		    mcpu?68030=march?68030 \
-		    mcpu?68040=march?68040 \
-		    mcpu?68060=march?68060 \
 		    mcpu?cpu32=march?cpu32
+
+MULTILIB_MATCHES += m68020-60=m68881 \
+		    m68020-60=m68020 \
+		    m68020-60=m68020-40 \
+		    m68020-60=mc68020 \
+		    m68020-60=m68030 \
+		    m68020-60=m68040 \
+		    m68020-60=m68060 \
+		    m68020-60=mcpu?68020 \
+		    m68020-60=mcpu?68030 \
+		    m68020-60=mcpu?68040 \
+		    m68020-60=mcpu?68060 \
+		    m68020-60=march?68020 \
+		    m68020-60=march?68030 \
+		    m68020-60=march?68040 \
+		    m68020-60=march?68060
 endif
 
 ifneq ($(M68K_ARCH),m68k)
 # Map -march=* options to the representative -mcpu=* option.
 MULTILIB_MATCHES += mcpu?5206e=march?isaa mcpu?5208=march?isaaplus \
 		    mcpu?5407=march?isab
+
+MULTILIB_MATCHES += mcpu?5475=mcfv4e \
+		    mcpu?5475=mcpu?5470 \
+		    mcpu?5475=mcpu?5471 \
+		    mcpu?5475=mcpu?5472 \
+		    mcpu?5475=mcpu?5473 \
+		    mcpu?5475=mcpu?5474 \
+		    mcpu?5475=mcpu?547x \
+		    mcpu?5475=mcpu?5480 \
+		    mcpu?5475=mcpu?5481 \
+		    mcpu?5475=mcpu?5482 \
+		    mcpu?5475=mcpu?5483 \
+		    mcpu?5475=mcpu?5484 \
+		    mcpu?5475=mcpu?5485 \
+		    mcpu?5475=mcpu?548x
 endif
 
 # Match non-representative -mcpu options to their representative option.
diff --git a/gcc/configure b/gcc/configure
index 6cb58cd6ec6..fb35cdcbca3 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -8169,7 +8169,7 @@ if test "${with_pkgversion+set}" = set; then :
       *)   PKGVERSION="($withval) " ;;
      esac
 else
-  PKGVERSION="(GCC) "
+  PKGVERSION="(GCC MiNT ELF) "
 
 fi
 
@@ -8187,7 +8187,7 @@ if test "${with_bugurl+set}" = set; then :
 	   ;;
      esac
 else
-  BUGURL="https://gcc.gnu.org/bugs/"
+  BUGURL="https://github.com/freemint/m68k-atari-mint-gcc/issues"
 
 fi
 
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 8382b4e7b3f..293e4b89fcf 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -1089,8 +1089,8 @@ AC_ARG_WITH(specs,
 )
 AC_SUBST(CONFIGURE_SPECS)
 
-ACX_PKGVERSION([GCC])
-ACX_BUGURL([https://gcc.gnu.org/bugs/])
+ACX_PKGVERSION([GCC MiNT ELF)
+ACX_BUGURL([https://github.com/freemint/m68k-atari-mint-gcc/issues])
 
 # Allow overriding the default URL for documentation
 AC_ARG_WITH(documentation-root-url,
diff --git a/gcc/explow.cc b/gcc/explow.cc
index 6424c0802f0..1852b8bb066 100644
--- a/gcc/explow.cc
+++ b/gcc/explow.cc
@@ -1575,7 +1575,12 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,
       stack_pointer_delta = saved_stack_pointer_delta;
 
       if (STACK_GROWS_DOWNWARD)
+	{
 	emit_move_insn (target, virtual_stack_dynamic_rtx);
+#ifdef STACK_CHECK_ATARI
+	m68k_emit_stack_check();
+#endif
+	}
     }
 
   suppress_reg_args_size = false;
diff --git a/gcc/expr.cc b/gcc/expr.cc
index 705d5b34eed..9fc354c3b2c 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -4930,7 +4930,11 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,
 	  size = gen_int_mode (GET_MODE_SIZE (mode), Pmode);
 	  if (!MEM_P (xinner))
 	    {
-	      temp = assign_temp (type, 1, 1);
+	      tree atype = type;
+
+	      if (atype == NULL)
+		atype = lang_hooks.types.type_for_mode (mode, 0);
+	      temp = assign_temp (atype, 1, 1);
 	      emit_move_insn (temp, xinner);
 	      xinner = temp;
 	    }
diff --git a/gcc/gcc.cc b/gcc/gcc.cc
index 319a045c285..d36b36378d9 100644
--- a/gcc/gcc.cc
+++ b/gcc/gcc.cc
@@ -7543,6 +7543,13 @@ print_configuration (FILE *file)
 #endif
 
   fnotice (file, "Thread model: %s\n", thrmod);
+  enum unwind_info_type unwind_info = targetm_common.except_unwind_info (&global_options);
+  fnotice (file, "Exceptions: %s\n",
+    unwind_info == UI_NONE ? "none" :
+    unwind_info == UI_SJLJ ? "SJLJ" :
+    unwind_info == UI_DWARF2 ? "Dwarf2" :
+    unwind_info == UI_SEH ? "SEH" :
+    "target");
   fnotice (file, "Supported LTO compression algorithms: zlib");
 #ifdef HAVE_ZSTD_H
   fnotice (file, " zstd");
diff --git a/gcc/gcov-tool.cc b/gcc/gcov-tool.cc
index 76173fdaef7..fbbf653259f 100644
--- a/gcc/gcov-tool.cc
+++ b/gcc/gcov-tool.cc
@@ -54,7 +54,7 @@ extern void gcov_set_verbose (void);
 /* Set to verbose output mode.  */
 static bool verbose;
 
-#if HAVE_FTW_H
+#if defined(HAVE_FTW_H) && defined(FTW_DEPTH)
 
 /* Remove file NAME if it has a gcda suffix. */
 
@@ -83,7 +83,7 @@ unlink_gcda_file (const char *name,
 static int
 unlink_profile_dir (const char *path ATTRIBUTE_UNUSED)
 {
-#if HAVE_FTW_H
+#if defined(HAVE_FTW_H) && defined(FTW_DEPTH)
     return nftw(path, unlink_gcda_file, 64, FTW_DEPTH | FTW_PHYS);
 #else
     return -1;
diff --git a/gcc/params.opt b/gcc/params.opt
index 653e0d8ba15..88c39c31d3c 100644
--- a/gcc/params.opt
+++ b/gcc/params.opt
@@ -607,7 +607,7 @@ Common Joined UInteger Var(param_max_modulo_backtrack_attempts) Init(40) Param O
 The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop.
 
 -param=min-pagesize=
-Common Joined UInteger Var(param_min_pagesize) Init(4096) Param Optimization
+Common Joined UInteger Var(param_min_pagesize) Init(0) Param Optimization
 Minimum page size for warning purposes.
 
 -param=max-partial-antic-length=
diff --git a/libada/configure b/libada/configure
index 9c8b133d817..a934cb8457c 100755
--- a/libada/configure
+++ b/libada/configure
@@ -3195,6 +3195,8 @@ case "${host}" in
 	;;
     i[34567]86-*-mingw* | x86_64-*-mingw*)
 	;;
+    *-*-mint*)
+	;;
     i[34567]86-*-interix[3-9]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
 	# Instead, we relocate shared libraries at runtime.
diff --git a/libcody/cody.hh b/libcody/cody.hh
index 789ce9e70b7..8bffdc80075 100644
--- a/libcody/cody.hh
+++ b/libcody/cody.hh
@@ -9,7 +9,7 @@
 // generally only good for requesting no networking
 #if !defined (CODY_NETWORKING)
 // Have a known-good list of networking systems
-#if defined (__unix__) || defined (__MACH__)
+#if (defined (__unix__) || defined (__MACH__)) && !defined (__MINT__)
 #define CODY_NETWORKING 1
 #else
 #define CODY_NETWORKING 0
diff --git a/libcody/resolver.cc b/libcody/resolver.cc
index 034fd63b9a8..5a7f6042ccd 100644
--- a/libcody/resolver.cc
+++ b/libcody/resolver.cc
@@ -11,6 +11,7 @@
 #include <sys/types.h>
 
 #if ((defined (__unix__)						\
+      && !defined(__MINT__)						\
       && defined _POSIX_C_SOURCE					\
       && (_POSIX_C_SOURCE - 0) >= 200809L)				\
      || (defined (__Apple__)						\
diff --git a/libgcc/config.host b/libgcc/config.host
index 9aa36bf2210..19eb8804b34 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -986,6 +986,13 @@ m68k-*-linux*)			# Motorola m68k's running GNU/Linux
 	fi
 	md_unwind_header=m68k/linux-unwind.h
 	;;
+m68k-*-mintelf*)
+	tmake_file="$tmake_file m68k/t-floatlib m68k/t-mint"
+	extra_parts="$extra_parts crtbegin.o crtend.o"
+	;;
+m68k-*-mint*)
+	tmake_file="$tmake_file m68k/t-floatlib m68k/t-mint"
+	;;
 m68k-*-rtems*)
 	tmake_file="$tmake_file m68k/t-floatlib"
 	extra_parts="$extra_parts crti.o crtn.o"
diff --git a/libgcc/config/m68k/mint-atomic.c b/libgcc/config/m68k/mint-atomic.c
new file mode 100644
index 00000000000..9bb9ff11a54
--- /dev/null
+++ b/libgcc/config/m68k/mint-atomic.c
@@ -0,0 +1,229 @@
+/* Linux-specific atomic operations for m68k Linux.
+   Copyright (C) 2011-2017 Free Software Foundation, Inc.
+   Based on code contributed by CodeSourcery for ARM EABI Linux.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Coldfire dropped the CAS instruction from the base M68K ISA.
+
+   GCC automatically issues a asm memory barrier when it encounters
+   a __sync_synchronize builtin.  Thus, we do not need to define this
+   builtin.
+
+   We implement byte, short and int versions of each atomic operation
+   using the kernel helper defined below.  There is no support for
+   64-bit operations yet.  */
+
+#include <stdbool.h>
+
+#ifndef __NR_atomic_cmpxchg_32
+#define __NR_atomic_cmpxchg_32  335
+#endif
+
+typedef unsigned int uint32_t __attribute__ ((mode (SI)));
+
+/* Kernel helper for compare-and-exchange a 32-bit value.  */
+static inline uint32_t
+__kernel_cmpxchg (volatile uint32_t *mem, uint32_t oldval, uint32_t newval)
+{
+#ifdef __linux__
+  register uint32_t *a0 asm("a0") = mem;
+  register uint32_t d2 asm("d2") = oldval;
+  register uint32_t d1 asm("d1") = newval;
+  register uint32_t d0 asm("d0") = __NR_atomic_cmpxchg_32;
+
+  asm volatile ("trap #0"
+		: "=r"(d0), "=r"(d1), "=r"(a0)
+		: "r"(d0), "r"(d1), "r"(d2), "r"(a0)
+		: "memory", "a1");
+
+  return d0;
+#else
+  volatile uint32_t *memp = (volatile uint32_t *)mem;
+  uint32_t memval = *memp;
+  if (memval == oldval)
+    *memp = newval;
+  return memval;
+#endif
+}
+
+#define HIDDEN __attribute__ ((visibility ("hidden")))
+
+/* Big endian masks  */
+#define INVERT_MASK_1 24
+#define INVERT_MASK_2 16
+
+#define MASK_1 0xffu
+#define MASK_2 0xffffu
+
+#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH
+#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH
+
+#define WORD_SYNC_OP(OP, PFX_OP, INF_OP, RETURN)			\
+  uint32_t HIDDEN							\
+  NAME##_##RETURN (OP, 4) (volatile void *ptr, uint32_t val)			\
+  {									\
+    volatile uint32_t *uptr = (volatile uint32_t *)ptr; \
+    uint32_t oldval, newval, cmpval = *uptr;				\
+									\
+    do {								\
+      oldval = cmpval;							\
+      newval = PFX_OP (oldval INF_OP val);				\
+      cmpval = __kernel_cmpxchg (uptr, oldval, newval);			\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return RETURN;							\
+  }
+
+#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, RTYPE, WIDTH, RETURN)	\
+  RTYPE HIDDEN								\
+  NAME##_##RETURN (OP, WIDTH) (volatile void *ptr, TYPE sval)			\
+  {									\
+    uint32_t *wordptr = (uint32_t *) ((unsigned long) ptr & ~3);	\
+    uint32_t mask, shift, oldval, newval, cmpval, wval;		\
+									\
+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
+    mask = MASK_##WIDTH << shift;					\
+    wval = (sval & MASK_##WIDTH) << shift;				\
+									\
+    cmpval = *wordptr;							\
+    do {								\
+      oldval = cmpval;							\
+      newval = PFX_OP (oldval INF_OP wval);				\
+      newval = (newval & mask) | (oldval & ~mask);			\
+      cmpval = __kernel_cmpxchg (wordptr, oldval, newval);		\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return (RETURN >> shift) & MASK_##WIDTH;				\
+  }
+
+WORD_SYNC_OP (add,   , +, oldval)
+WORD_SYNC_OP (sub,   , -, oldval)
+WORD_SYNC_OP (or,    , |, oldval)
+WORD_SYNC_OP (and,   , &, oldval)
+WORD_SYNC_OP (xor,   , ^, oldval)
+WORD_SYNC_OP (nand, ~, &, oldval)
+
+#ifdef __MSHORT__
+#define SHORTINT unsigned int
+#else
+#define SHORTINT unsigned short
+#endif
+
+SUBWORD_SYNC_OP (add,   , +, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (sub,   , -, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (or,    , |, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (and,   , &, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (xor,   , ^, SHORTINT, SHORTINT, 2, oldval)
+SUBWORD_SYNC_OP (nand, ~, &, SHORTINT, SHORTINT, 2, oldval)
+
+SUBWORD_SYNC_OP (add,   , +, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (sub,   , -, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (or,    , |, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (and,   , &, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, unsigned char, 1, oldval)
+
+WORD_SYNC_OP (add,   , +, newval)
+WORD_SYNC_OP (sub,   , -, newval)
+WORD_SYNC_OP (or,    , |, newval)
+WORD_SYNC_OP (and,   , &, newval)
+WORD_SYNC_OP (xor,   , ^, newval)
+WORD_SYNC_OP (nand, ~, &, newval)
+
+SUBWORD_SYNC_OP (add,   , +, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (sub,   , -, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (or,    , |, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (and,   , &, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (xor,   , ^, SHORTINT, SHORTINT, 2, newval)
+SUBWORD_SYNC_OP (nand, ~, &, SHORTINT, SHORTINT, 2, newval)
+
+SUBWORD_SYNC_OP (add,   , +, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (sub,   , -, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (or,    , |, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (and,   , &, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (xor,   , ^, unsigned char, unsigned char, 1, newval)
+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, unsigned char, 1, newval)
+
+uint32_t HIDDEN
+__sync_val_compare_and_swap_4 (volatile void *ptr, uint32_t oldval, uint32_t newval)
+{
+  return __kernel_cmpxchg ((volatile uint32_t *) ptr, oldval, newval);
+}
+
+bool HIDDEN
+__sync_bool_compare_and_swap_4 (volatile void *ptr, uint32_t oldval,
+				uint32_t newval)
+{
+  return __kernel_cmpxchg ((volatile uint32_t *) ptr, oldval, newval) == oldval;
+}
+
+#define SUBWORD_VAL_CAS(TYPE, WIDTH)					\
+  TYPE HIDDEN								\
+  __sync_val_compare_and_swap_##WIDTH (volatile void *ptr, TYPE soldval,		\
+				       TYPE snewval)			\
+  {									\
+    uint32_t *wordptr = (uint32_t *)((unsigned long) ptr & ~3);		\
+    uint32_t mask, shift, woldval, wnewval;				\
+    uint32_t oldval, newval, cmpval;					\
+									\
+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
+    mask = MASK_##WIDTH << shift;					\
+    woldval = (soldval & MASK_##WIDTH) << shift;			\
+    wnewval = (snewval & MASK_##WIDTH) << shift;			\
+    cmpval = *wordptr;							\
+									\
+    do {								\
+      oldval = cmpval;							\
+      if ((oldval & mask) != woldval)					\
+	break;								\
+      newval = (oldval & ~mask) | wnewval;				\
+      cmpval = __kernel_cmpxchg (wordptr, oldval, newval);		\
+    } while (__builtin_expect (oldval != cmpval, 0));			\
+									\
+    return (oldval >> shift) & MASK_##WIDTH;				\
+  }
+
+SUBWORD_VAL_CAS (SHORTINT, 2)
+SUBWORD_VAL_CAS (unsigned char,  1)
+
+#define SUBWORD_BOOL_CAS(TYPE, WIDTH)					\
+  bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (volatile void *ptr, TYPE oldval,		\
+					TYPE newval)			\
+  {									\
+    return (__sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval)	\
+	    == oldval);							\
+  }
+
+SUBWORD_BOOL_CAS (SHORTINT, 2)
+SUBWORD_BOOL_CAS (unsigned char,  1)
+
+#undef NAME_oldval
+#define NAME_oldval(OP, WIDTH) __sync_lock_##OP##_##WIDTH
+#define COMMA ,
+
+#pragma GCC diagnostic ignored "-Wunused-value"
+
+WORD_SYNC_OP (test_and_set, , COMMA, oldval)
+SUBWORD_SYNC_OP (test_and_set, , COMMA, unsigned char, unsigned char, 1, oldval)
+SUBWORD_SYNC_OP (test_and_set, , COMMA, SHORTINT, SHORTINT, 2, oldval)
diff --git a/libgcc/config/m68k/t-mint b/libgcc/config/m68k/t-mint
new file mode 100644
index 00000000000..c768fc121b0
--- /dev/null
+++ b/libgcc/config/m68k/t-mint
@@ -0,0 +1 @@
+LIB2ADD_ST = $(srcdir)/config/m68k/mint-atomic.c
diff --git a/libgcc/configure b/libgcc/configure
index be5d45f1755..b34defddbfb 100755
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -2386,6 +2386,8 @@ case "${host}" in
 	;;
     i[34567]86-*-mingw* | x86_64-*-mingw*)
 	;;
+    *-*-mint*)
+	;;
     i[34567]86-*-interix[3-9]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
 	# Instead, we relocate shared libraries at runtime.
diff --git a/libgcc/crtstuff.c b/libgcc/crtstuff.c
index 93ff5b81dc5..3fbe609c82b 100644
--- a/libgcc/crtstuff.c
+++ b/libgcc/crtstuff.c
@@ -198,7 +198,12 @@ extern void _ITM_deregisterTMCloneTable (void *) TARGET_ATTRIBUTE_WEAK;
 
 /*  Declare a pointer to void function type.  */
 typedef void (*func_ptr) (void);
+#ifdef HAS_INIT_SECTION
 #define STATIC static
+#else
+/* Define global arrays because they are referred by __main.o.  */
+#define STATIC
+#endif
 
 #else  /* OBJECT_FORMAT_ELF */
 
@@ -252,6 +257,7 @@ STATIC func_ptr __DTOR_LIST__[1]
   = { (func_ptr) (-1) };
 #else
 STATIC func_ptr __DTOR_LIST__[1]
+  __attribute__((__used__))
   __attribute__((section(".dtors"), aligned(__alignof__(func_ptr))))
   = { (func_ptr) (-1) };
 #endif /* __DTOR_LIST__ alternatives */
@@ -260,7 +266,9 @@ STATIC func_ptr __DTOR_LIST__[1]
 #ifdef USE_EH_FRAME_REGISTRY
 /* Stick a label at the beginning of the frame unwind info so we can register
    and deregister it with the exception handling library code.  */
+
 STATIC EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]
+     __attribute__((__used__))
      __attribute__((section(__LIBGCC_EH_FRAME_SECTION_NAME__),
 		    aligned(__alignof__ (void *))))
      = { };
@@ -594,6 +602,8 @@ __do_global_ctors_1(void)
 }
 #endif /* USE_EH_FRAME_REGISTRY || USE_TM_CLONE_REGISTRY */
 
+#elif defined(__MINT__) && defined(__ELF__)
+/* already done in libgcc2.c */
 #else /* ! __LIBGCC_INIT_SECTION_ASM_OP__ && ! HAS_INIT_SECTION */
 #error "What are you doing with crtstuff.c, then?"
 #endif
@@ -621,6 +631,7 @@ STATIC func_ptr __CTOR_END__[1]
   = { (func_ptr) 0 };
 #else
 STATIC func_ptr __CTOR_END__[1]
+  __attribute__((__used__))
   __attribute__((section(".ctors"), aligned(__alignof__(func_ptr))))
   = { (func_ptr) 0 };
 #endif
@@ -753,6 +764,8 @@ __do_global_ctors (void)
     (*p) ();
 }
 
+#elif defined(__MINT__) && defined(__ELF__)
+/* already done in libgcc2.c */
 #else /* ! __LIBGCC_INIT_SECTION_ASM_OP__ && ! HAS_INIT_SECTION */
 #error "What are you doing with crtstuff.c, then?"
 #endif
diff --git a/libgcc/libgcc2.c b/libgcc/libgcc2.c
index e0017d106be..92ea6d5cc7e 100644
--- a/libgcc/libgcc2.c
+++ b/libgcc/libgcc2.c
@@ -2445,6 +2445,9 @@ SYMBOL__MAIN (void)
 
    Long term no port should use those extensions.  But many still do.  */
 #if !defined(__LIBGCC_INIT_SECTION_ASM_OP__)
+#if defined(__MINT__) && defined(__ELF__)
+/* nothing; we use the definitions from crtstuff.c now */
+#else
 #if defined (TARGET_ASM_CONSTRUCTOR) || defined (USE_COLLECT2)
 func_ptr __CTOR_LIST__[2] = {0, 0};
 func_ptr __DTOR_LIST__[2] = {0, 0};
@@ -2452,6 +2455,7 @@ func_ptr __DTOR_LIST__[2] = {0, 0};
 func_ptr __CTOR_LIST__[2];
 func_ptr __DTOR_LIST__[2];
 #endif
+#endif
 #endif /* no __LIBGCC_INIT_SECTION_ASM_OP__ */
 #endif /* L_ctors */
 #endif /* LIBGCC2_UNITS_PER_WORD <= MIN_UNITS_PER_WORD */
diff --git a/libgcc/unwind-c.c b/libgcc/unwind-c.c
index 2da3d56d7f9..5dc84282b8c 100644
--- a/libgcc/unwind-c.c
+++ b/libgcc/unwind-c.c
@@ -244,3 +244,7 @@ __gcc_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,
 				ms_disp, __gcc_personality_imp);
 }
 #endif /* SEH */
+
+#ifdef __MINT__
+void *__DW_EH_PE_aligned_var __attribute__((__aligned__(sizeof(void *))));
+#endif
diff --git a/libgcc/unwind-pe.h b/libgcc/unwind-pe.h
index 3f98c93589a..3e90daf5072 100644
--- a/libgcc/unwind-pe.h
+++ b/libgcc/unwind-pe.h
@@ -201,7 +201,18 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,
   if (encoding == DW_EH_PE_aligned)
     {
       _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;
+#ifdef __MINT__
+      /*
+       * alignment to pointer size cannot be guaranteed by TOS at runtime
+       */
+      extern void *__DW_EH_PE_aligned_var;
+      _Unwind_Internal_Ptr base_offset = ((_Unwind_Internal_Ptr)&__DW_EH_PE_aligned_var) & 3;
+      a += base_offset; /* Where it should have been located */
+#endif
       a = (a + sizeof (void *) - 1) & - sizeof(void *);
+#ifdef __MINT__
+      a -= base_offset; /* Where it is actually aligned */
+#endif
       result = *(_Unwind_Internal_Ptr *) a;
       p = (const unsigned char *) (_Unwind_Internal_Ptr) (a + sizeof (void *));
     }
diff --git a/libiberty/configure b/libiberty/configure
index 860f981fa18..123b97966a1 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -5192,6 +5192,8 @@ case "${host}" in
 	;;
     i[34567]86-*-mingw* | x86_64-*-mingw*)
 	;;
+    *-*-mint*)
+	;;
     i[34567]86-*-interix[3-9]*)
 	# Interix 3.x gcc -fpic/-fPIC options generate broken code.
 	# Instead, we relocate shared libraries at runtime.
diff --git a/libssp/ssp.c b/libssp/ssp.c
index d37cca6256b..99df37f853f 100644
--- a/libssp/ssp.c
+++ b/libssp/ssp.c
@@ -66,6 +66,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef HAVE_SYSLOG_H
 # include <syslog.h>
 #endif
+#ifdef __MINT__
+#include <mint/osbind.h>
+#endif
 
 void *__stack_chk_guard = 0;
 
@@ -115,6 +118,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
 {
 #ifdef __GNU_LIBRARY__
   extern char * __progname;
+#elif defined (__MINT__)
+  extern char * program_invocation_short_name;
+  #define __progname program_invocation_short_name
 #else
   static const char __progname[] = "";
 #endif
@@ -156,6 +162,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
     syslog (LOG_CRIT, "%s", msg3);
 #endif /* HAVE_SYSLOG_H */
 
+#ifdef __MINT__
+    Pterm(127);
+#else
   /* Try very hard to exit.  Note that signals may be blocked preventing
      the first two options from working.  The use of volatile is here to
      prevent optimizers from "knowing" that __builtin_trap is called first,
@@ -177,6 +186,7 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
           break;
         }
   }
+#endif
 }
 
 void
diff --git a/libstdc++-v3/config/os/mint/ctype_base.h b/libstdc++-v3/config/os/mint/ctype_base.h
new file mode 100644
index 00000000000..0f2e672c6fe
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_base.h
@@ -0,0 +1,67 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+//  We don't use the C-locale masks defined in /usr/include/ctype.h
+//  because those masks do not conform to the requirements of 22.2.1.
+//  In particular, a separate 'print' bitmask does not exist (isprint(c)
+//  relies on a combination of flags) and the  '_ALPHA' mask is also a
+//  combination of simple bitmasks.  Thus, we define libstdc++-specific
+//  masks here, based on the generic masks, and the corresponding
+//  classic_table in ctype_noninline.h.
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned short 	mask;
+    static const mask upper	= 1 << 0;
+    static const mask lower	= 1 << 1;
+    static const mask alpha	= 1 << 2;
+    static const mask digit	= 1 << 3;
+    static const mask xdigit	= 1 << 4;
+    static const mask space	= 1 << 5;
+    static const mask print	= 1 << 6;
+    static const mask graph	= (1 << 2) | (1 << 3) | (1 << 9);  // alnum|punct
+    static const mask cntrl	= 1 << 8;
+    static const mask punct 	= 1 << 9;
+    static const mask alnum	= (1 << 2) | (1 << 3);  // alpha|digit
+#if __cplusplus >= 201103L
+    static const mask blank	= 1 << 10;
+#endif
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_configure_char.cc b/libstdc++-v3/config/os/mint/ctype_configure_char.cc
new file mode 100644
index 00000000000..e4e19bf5d24
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_configure_char.cc
@@ -0,0 +1,243 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // The classic table used in libstdc++ is *not* the C _ctype table
+  // used by mscvrt, but is based on the ctype masks defined for libstdc++
+  // in ctype_base.h.
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  {
+    static const ctype_base::mask _S_classic_table[256] =
+    {
+      cntrl /* null */,
+      cntrl /* ^A */,
+      cntrl /* ^B */,
+      cntrl /* ^C */,
+      cntrl /* ^D */,
+      cntrl /* ^E */,
+      cntrl /* ^F */,
+      cntrl /* ^G */,
+      cntrl /* ^H */,
+      ctype_base::mask(space | cntrl | blank) /* tab */,
+      ctype_base::mask(space | cntrl) /* LF */,
+      ctype_base::mask(space | cntrl) /* ^K */,
+      ctype_base::mask(space | cntrl) /* FF */,
+      ctype_base::mask(space | cntrl) /* ^M */,
+      cntrl /* ^N */,
+      cntrl /* ^O */,
+      cntrl /* ^P */,
+      cntrl /* ^Q */,
+      cntrl /* ^R */,
+      cntrl /* ^S */,
+      cntrl /* ^T */,
+      cntrl /* ^U */,
+      cntrl /* ^V */,
+      cntrl /* ^W */,
+      cntrl /* ^X */,
+      cntrl /* ^Y */,
+      cntrl /* ^Z */,
+      cntrl /* esc */,
+      cntrl /* ^\ */,
+      cntrl /* ^] */,
+      cntrl /* ^^ */,
+      cntrl /* ^_ */,
+      ctype_base::mask(space | print | blank) /*   */,
+      ctype_base::mask(punct | print) /* ! */,
+      ctype_base::mask(punct | print) /* " */,
+      ctype_base::mask(punct | print) /* # */,
+      ctype_base::mask(punct | print) /* $ */,
+      ctype_base::mask(punct | print) /* % */,
+      ctype_base::mask(punct | print) /* & */,
+      ctype_base::mask(punct | print) /* ' */,
+      ctype_base::mask(punct | print) /* ( */,
+      ctype_base::mask(punct | print) /* ) */,
+      ctype_base::mask(punct | print) /* * */,
+      ctype_base::mask(punct | print) /* + */,
+      ctype_base::mask(punct | print) /* , */,
+      ctype_base::mask(punct | print) /* - */,
+      ctype_base::mask(punct | print) /* . */,
+      ctype_base::mask(punct | print) /* / */,
+      ctype_base::mask(digit | xdigit | print) /* 0 */,
+      ctype_base::mask(digit | xdigit | print) /* 1 */,
+      ctype_base::mask(digit | xdigit | print) /* 2 */,
+      ctype_base::mask(digit | xdigit | print) /* 3 */,
+      ctype_base::mask(digit | xdigit | print) /* 4 */,
+      ctype_base::mask(digit | xdigit | print) /* 5 */,
+      ctype_base::mask(digit | xdigit | print) /* 6 */,
+      ctype_base::mask(digit | xdigit | print) /* 7 */,
+      ctype_base::mask(digit | xdigit | print) /* 8 */,
+      ctype_base::mask(digit | xdigit | print) /* 9 */,
+      ctype_base::mask(punct | print) /* : */,
+      ctype_base::mask(punct | print) /* ; */,
+      ctype_base::mask(punct | print) /* < */,
+      ctype_base::mask(punct | print) /* = */,
+      ctype_base::mask(punct | print) /* > */,
+      ctype_base::mask(punct | print) /* ? */,
+      ctype_base::mask(punct | print) /* ! */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* A */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* B */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* C */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* D */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* E */,
+      ctype_base::mask(alpha | upper | xdigit | print) /* F */,
+      ctype_base::mask(alpha | upper | print) /* G */,
+      ctype_base::mask(alpha | upper | print) /* H */,
+      ctype_base::mask(alpha | upper | print) /* I */,
+      ctype_base::mask(alpha | upper | print) /* J */,
+      ctype_base::mask(alpha | upper | print) /* K */,
+      ctype_base::mask(alpha | upper | print) /* L */,
+      ctype_base::mask(alpha | upper | print) /* M */,
+      ctype_base::mask(alpha | upper | print) /* N */,
+      ctype_base::mask(alpha | upper | print) /* O */,
+      ctype_base::mask(alpha | upper | print) /* P */,
+      ctype_base::mask(alpha | upper | print) /* Q */,
+      ctype_base::mask(alpha | upper | print) /* R */,
+      ctype_base::mask(alpha | upper | print) /* S */,
+      ctype_base::mask(alpha | upper | print) /* T */,
+      ctype_base::mask(alpha | upper | print) /* U */,
+      ctype_base::mask(alpha | upper | print) /* V */,
+      ctype_base::mask(alpha | upper | print) /* W */,
+      ctype_base::mask(alpha | upper | print) /* X */,
+      ctype_base::mask(alpha | upper | print) /* Y */,
+      ctype_base::mask(alpha | upper | print) /* Z */,
+      ctype_base::mask(punct | print) /* [ */,
+      ctype_base::mask(punct | print) /* \ */,
+      ctype_base::mask(punct | print) /* ] */,
+      ctype_base::mask(punct | print) /* ^ */,
+      ctype_base::mask(punct | print) /* _ */,
+      ctype_base::mask(punct | print) /* ` */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* a */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* b */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* c */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* d */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* e */,
+      ctype_base::mask(alpha | lower | xdigit | print) /* f */,
+      ctype_base::mask(alpha | lower | print) /* g */,
+      ctype_base::mask(alpha | lower | print) /* h */,
+      ctype_base::mask(alpha | lower | print) /* i */,
+      ctype_base::mask(alpha | lower | print) /* j */,
+      ctype_base::mask(alpha | lower | print) /* k */,
+      ctype_base::mask(alpha | lower | print) /* l */,
+      ctype_base::mask(alpha | lower | print) /* m */,
+      ctype_base::mask(alpha | lower | print) /* n */,
+      ctype_base::mask(alpha | lower | print) /* o */,
+      ctype_base::mask(alpha | lower | print) /* p */,
+      ctype_base::mask(alpha | lower | print) /* q */,
+      ctype_base::mask(alpha | lower | print) /* r */,
+      ctype_base::mask(alpha | lower | print) /* s */,
+      ctype_base::mask(alpha | lower | print) /* t */,
+      ctype_base::mask(alpha | lower | print) /* u */,
+      ctype_base::mask(alpha | lower | print) /* v */,
+      ctype_base::mask(alpha | lower | print) /* w */,
+      ctype_base::mask(alpha | lower | print) /* x */,
+      ctype_base::mask(alpha | lower | print) /* y */,
+      ctype_base::mask(alpha | lower | print) /* x */,
+      ctype_base::mask(punct | print) /* { */,
+      ctype_base::mask(punct | print) /* | */,
+      ctype_base::mask(punct | print) /* } */,
+      ctype_base::mask(punct | print) /* ~ */,
+      cntrl /* del (0x7f)*/,
+      /* The next 128 entries are all 0.   */
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+    };
+    return _S_classic_table;
+  }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
+		     size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return (this->is(ctype_base::lower, __c) ? (__c - 'a' + 'A') : __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = this->do_toupper(*__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return (this->is(ctype_base::upper, __c) ? (__c - 'A' + 'a') : __c); }
+
+  const char*
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = this->do_tolower(*__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_inline.h b/libstdc++-v3/config/os/mint/ctype_inline.h
new file mode 100644
index 00000000000..b2d7b9861bf
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_inline.h
@@ -0,0 +1,75 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }
+
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    while (__low < __high)
+      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && !this->is(__m, *__low))
+      ++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && this->is(__m, *__low) != 0)
+      ++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/os_defines.h b/libstdc++-v3/config/os/mint/os_defines.h
new file mode 100644
index 00000000000..d0cae2be395
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/os_defines.h
@@ -0,0 +1,36 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#  define _GLIBCXX_OS_DEFINES
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+#endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 81329bba8e5..f599f3d5ebd 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -48051,7 +48051,7 @@ $as_echo "#define HAVE_TLS 1" >>confdefs.h
 
   fi
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index 9e7c7f02dfd..58bc5e8d70b 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -283,6 +283,10 @@ case "${host_os}" in
     esac
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
+  mint*)
+    SECTION_FLAGS="${SECTION_FLAGS} -D_GNU_SOURCE"
+    os_include_dir="os/mint"
+    ;;
   netbsd*)
     os_include_dir="os/bsd/netbsd"
     ;;
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index b3269cb88e0..0f1e1551778 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -174,7 +174,7 @@ case "${host}" in
 
     GCC_CHECK_TLS
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
diff --git a/libstdc++-v3/src/c++17/fast_float/fast_float.h b/libstdc++-v3/src/c++17/fast_float/fast_float.h
index 7551c4f89ef..7b2b7ac672e 100644
--- a/libstdc++-v3/src/c++17/fast_float/fast_float.h
+++ b/libstdc++-v3/src/c++17/fast_float/fast_float.h
@@ -102,7 +102,7 @@ from_chars_result from_chars_advanced(const char *first, const char *last,
 #define FASTFLOAT_64BIT 1
 #elif (defined(__i386) || defined(__i386__) || defined(_M_IX86)   \
      || defined(__arm__) || defined(_M_ARM)                   \
-     || defined(__MINGW32__) || defined(__EMSCRIPTEN__))
+     || defined(__MINGW32__) || defined(__EMSCRIPTEN__) || defined(__m68k__))
 #define FASTFLOAT_32BIT 1
 #else
   // Need to check incrementally, since SIZE_MAX is a size_t, avoid overflow.
@@ -2562,7 +2562,7 @@ void round_nearest_tie_even(adjusted_mantissa& am, int32_t shift, callback cb) n
   uint64_t mask;
   uint64_t halfway;
   if (shift == 64) {
-    mask = UINT64_MAX;
+    mask = __UINT64_MAX__;
   } else {
     mask = (uint64_t(1) << shift) - 1;
   }
diff --git a/libstdc++-v3/src/c++17/ryu/f2s_intrinsics.h b/libstdc++-v3/src/c++17/ryu/f2s_intrinsics.h
index db751a41329..2ad8c894c48 100644
--- a/libstdc++-v3/src/c++17/ryu/f2s_intrinsics.h
+++ b/libstdc++-v3/src/c++17/ryu/f2s_intrinsics.h
@@ -89,7 +89,7 @@ static inline uint32_t mulShift32(const uint32_t m, const uint64_t factor, const
 #else // RYU_32_BIT_PLATFORM
   const uint64_t sum = (bits0 >> 32) + bits1;
   const uint64_t shiftedSum = sum >> (shift - 32);
-  assert(shiftedSum <= UINT32_MAX);
+  assert(shiftedSum <= __UINT32_MAX__);
   return (uint32_t) shiftedSum;
 #endif // RYU_32_BIT_PLATFORM
 }
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 7fa2af2ea97..bc834facc1e 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -260,7 +260,7 @@ namespace __gnu_posix
   file_time(const stat_type& st, std::error_code& ec) noexcept
   {
     using namespace std::chrono;
-#ifdef _GLIBCXX_USE_ST_MTIM
+#if defined(_GLIBCXX_USE_ST_MTIM) && !defined(__MINT__)
     time_t s = st.st_mtim.tv_sec;
     nanoseconds ns{st.st_mtim.tv_nsec};
 #else
