diff -N -rbU5 SDL-1.2.11.orig/configure.in SDL-1.2.11/configure.in
--- SDL-1.2.11.orig/configure.in	2020-04-13 13:02:59.445793991 +0200
+++ SDL-1.2.11/configure.in	2020-04-13 13:03:14.824238248 +0200
@@ -131,11 +131,14 @@
     fi
     AC_FUNC_STRTOD
     if test x$ac_cv_func_strtod = xyes; then
         AC_DEFINE(HAVE_STRTOD)
     fi
-    AC_CHECK_FUNCS(malloc calloc realloc free getenv putenv unsetenv qsort abs bcopy memset memcpy memmove strlen strlcpy strlcat strdup _strrev _strupr _strlwr strchr strrchr strstr itoa _ltoa _uitoa _ultoa strtol strtoul _i64toa _ui64toa strtoll strtoull atoi atof strcmp strncmp _stricmp strcasecmp _strnicmp strncasecmp sscanf snprintf vsnprintf iconv sigaction setjmp nanosleep)
+#DKS - disabled check for nanosleep, we don't want to use it, it causes problems with
+#			SDL_Delay on GP2X
+#    AC_CHECK_FUNCS(malloc calloc realloc free getenv putenv unsetenv qsort abs bcopy memset memcpy memmove strlen strlcpy strlcat strdup _strrev _strupr _strlwr strchr strrchr strstr itoa _ltoa _uitoa _ultoa strtol strtoul _i64toa _ui64toa strtoll strtoull atoi atof strcmp strncmp _stricmp strcasecmp _strnicmp strncasecmp sscanf snprintf vsnprintf iconv sigaction setjmp nanosleep)
+    AC_CHECK_FUNCS(malloc calloc realloc free getenv putenv unsetenv qsort abs bcopy memset memcpy memmove strlen strlcpy strlcat strdup _strrev _strupr _strlwr strchr strrchr strstr itoa _ltoa _uitoa _ultoa strtol strtoul _i64toa _ui64toa strtoll strtoull atoi atof strcmp strncmp _stricmp strcasecmp _strnicmp strncasecmp sscanf snprintf vsnprintf iconv sigaction setjmp)
 
     AC_CHECK_LIB(iconv, libiconv_open, [EXTRA_LDFLAGS="$EXTRA_LDFLAGS -liconv"])
     AC_CHECK_LIB(m, pow, [EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lm"])
 fi
 
@@ -1097,10 +1100,26 @@
             have_video=yes
         fi
     fi
 }
 
+dnl paeryn/djwillis 27072007 Set up the GP2X video driver.
+CheckGP2X()
+{
+    AC_ARG_ENABLE(video-gp2x,
+AC_HELP_STRING([--enable-video-gp2x], [use gp2x video driver [[default=yes]]]),
+                  , enable_video_gp2x=yes)
+    if test x$enable_video = xyes -a x$enable_video_gp2x = xyes; then
+	AC_MSG_CHECKING(for GP2X support)
+	video_gp2x=yes
+	AC_DEFINE(SDL_VIDEO_DRIVER_GP2X)
+	SOURCES="$SOURCES $srcdir/src/video/ARM_blit1to2.S"
+	SOURCES="$SOURCES $srcdir/src/video/gp2x/*.c"
+	have_video=yes
+    fi
+}
+
 dnl Find the framebuffer console includes
 CheckFBCON()
 {
     AC_ARG_ENABLE(video-fbcon,
 AC_HELP_STRING([--enable-video-fbcon], [use framebuffer console video driver [[default=yes]]]),
@@ -2140,10 +2159,11 @@
         CheckMME
         CheckALSA
         CheckARTSC
         CheckESD
         CheckNAS
+        CheckGP2X
         CheckX11
         CheckNANOX
         CheckFBCON
         CheckDirectFB
         CheckPS2GS
diff -N -rbU5 SDL-1.2.11.orig/include/SDL_config.h.in SDL-1.2.11/include/SDL_config.h.in
--- SDL-1.2.11.orig/include/SDL_config.h.in	2020-04-13 13:02:59.485795147 +0200
+++ SDL-1.2.11/include/SDL_config.h.in	2020-04-13 13:03:31.041706739 +0200
@@ -192,18 +192,18 @@
 #undef SDL_CDROM_OSF
 #undef SDL_CDROM_QNX
 #undef SDL_CDROM_WIN32
 
 /* Enable various input drivers */
+#undef SDL_INPUT_LINUXEV
 #undef SDL_INPUT_TSLIB
 #undef SDL_JOYSTICK_AMIGA
 #undef SDL_JOYSTICK_BEOS
 #undef SDL_JOYSTICK_DC
 #undef SDL_JOYSTICK_DUMMY
 #undef SDL_JOYSTICK_IOKIT
 #undef SDL_JOYSTICK_LINUX
-#undef SDL_JOYSTICK_LINUXEV
 #undef SDL_JOYSTICK_MACOS
 #undef SDL_JOYSTICK_MINT
 #undef SDL_JOYSTICK_OS2
 #undef SDL_JOYSTICK_RISCOS
 #undef SDL_JOYSTICK_WINMM
@@ -260,10 +260,11 @@
 #undef SDL_VIDEO_DRIVER_EPOC
 #undef SDL_VIDEO_DRIVER_FBCON
 #undef SDL_VIDEO_DRIVER_GAPI
 #undef SDL_VIDEO_DRIVER_GEM
 #undef SDL_VIDEO_DRIVER_GGI
+#undef SDL_VIDEO_DRIVER_GP2X
 #undef SDL_VIDEO_DRIVER_IPOD
 #undef SDL_VIDEO_DRIVER_NANOX
 #undef SDL_VIDEO_DRIVER_OS2FS
 #undef SDL_VIDEO_DRIVER_PHOTON
 #undef SDL_VIDEO_DRIVER_PICOGUI
diff -N -rbU5 SDL-1.2.11.orig/include/SDL_gp2x.h SDL-1.2.11/include/SDL_gp2x.h
--- SDL-1.2.11.orig/include/SDL_gp2x.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/include/SDL_gp2x.h	2020-04-13 13:03:49.356235798 +0200
@@ -0,0 +1,70 @@
+/*
+ * Non-standard SDL header.
+ *
+ * This header gives access to a few extra features of the GP2X hardware
+ * that I added to the video driver.
+ */
+
+#ifndef SDL_GP2X__H
+#define SDL_GP2X__H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GP2X_MOUSE_NONE        0
+#define GP2X_MOUSE_STD         1
+#define GP2X_MOUSE_TOUCHSCREEN 2
+
+  
+void SDL_GP2X_SetMonoColours(int background, int foreground);
+int  SDL_GP2X_GetPhysicalScreenSize(SDL_Rect *size);
+void SDL_GP2X_Display(SDL_Rect *area);
+void SDL_GP2X_InitializeCursor();
+void SDL_GP2X_SetCursorColour(WMcursor *wcursor,
+			      int bred, int bgreen, int bblue, int balpha,
+			      int fred, int fgreen, int fblue, int falpha);
+void SDL_GP2X_DefineRegion(int region, SDL_Rect *area);
+void SDL_GP2X_ActivateRegion(int region, int activate);
+void SDL_GP2X_MiniDisplay(int x, int y);
+void SDL_GP2X_WaitForBlitter();
+
+int  SDL_GP2X_TV(int state);
+int  SDL_GP2X_TVMode(int mode);
+void SDL_GP2X_TVAdjust(int direction);
+
+void SDL_GP2X_AllowGfxMemory(char *start, int size);
+void SDL_GP2X_DenyGfxMemory(char *start, int size);
+
+void SDL_GP2X_VSync();
+
+// Return a hardware surface's bitmap address for use by the 940
+//  Surface has to be SDL_HWSURFACE *and* SDL_LockSurface()ed
+//  When you unlock the surface the address you got from here *must*
+//  be considered invalid.
+void *SDL_GP2X_PhysAddress(SDL_Surface *surface);
+
+// Query GP2X mouse type
+int SDL_GP2X_MouseType();
+
+// Get (semi-)raw touchpad position (not SDL position)
+//   0 <= x <= 319, 0 <= y <= 239
+//   Return value is pressure (any non zero value means pressed)
+int SDL_GP2X_Touchpad(int *x, int *y);
+
+// Enable (1) or disable (0) the touchscreen stylus from causing mouse button events.  
+// In some games/apps it is desirable to have the stylus only used for positioning of
+// the cursor with clicking done by joystick buttons. Default is enabled.
+void SDL_GP2X_TouchpadMouseButtonEvents(int enabled);
+
+// Enable (1) or disable (0) the touchscreen stylus from causing mouse motion events or
+// registering changes in cursor state.  Sometimes a developer may wish to easily
+// disable the touchscreen and not have to modify large sections of code in a porting
+// project. Default is enabled.
+void SDL_GP2X_TouchpadMouseMotionEvents(int enabled);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -N -rbU5 SDL-1.2.11.orig/include/SDL_joystick.h SDL-1.2.11/include/SDL_joystick.h
--- SDL-1.2.11.orig/include/SDL_joystick.h	2020-04-13 13:02:59.485795147 +0200
+++ SDL-1.2.11/include/SDL_joystick.h	2020-04-13 13:04:00.817566884 +0200
@@ -155,10 +155,50 @@
 /*
  * Close a joystick previously opened with SDL_JoystickOpen()
  */
 extern DECLSPEC void SDLCALL SDL_JoystickClose(SDL_Joystick *joystick);
 
+/*
+ * GP2X backlight control (as it's connected to GPIO)
+ */
+#define IOCTL_GP2X_CONTROL_LIB    _IOR('v', 0x00 ,unsigned long)
+#define BACK_LIGHT_OFF		0
+#define BACK_LIGHT_ON		1
+#define BATT_LED_ON		2
+#define BATT_LED_OFF		3
+
+#define FCLK_200			10
+#define FCLK_166			11
+#define FCLK_133			12
+#define FCLK_100			13	
+#define FCLK_78				14
+#define FCLK_64				15
+#define FCLK_DEFAULT		        16
+
+enum {             // GP2X joystick button numbers
+  GP2X_VK_UP = 0,
+  GP2X_VK_UP_LEFT,
+  GP2X_VK_LEFT,
+  GP2X_VK_DOWN_LEFT,
+  GP2X_VK_DOWN,
+  GP2X_VK_DOWN_RIGHT,
+  GP2X_VK_RIGHT,
+  GP2X_VK_UP_RIGHT,
+  GP2X_VK_START,
+  GP2X_VK_SELECT,
+  GP2X_VK_FL,
+  GP2X_VK_FR,
+  GP2X_VK_FA,
+  GP2X_VK_FB,
+  GP2X_VK_FX,
+  GP2X_VK_FY,
+  GP2X_VK_VOL_UP,
+  GP2X_VK_VOL_DOWN,
+  GP2X_VK_STICK_PUSH
+};
+
+void SDL_SYS_JoystickGp2xSys(SDL_Joystick *joystick,int cmd);
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
 }
 #endif
diff -N -rbU5 SDL-1.2.11.orig/README.GP2X SDL-1.2.11/README.GP2X
--- SDL-1.2.11.orig/README.GP2X	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/README.GP2X	2020-04-13 13:04:16.761027449 +0200
@@ -0,0 +1,293 @@
+----------------------------------------
+|Open2x - SDL Port to use GP2X hardware|
+----------------------------------------
+
+Version: SDL for the GP2X (Based on SDL 1.2.11)
+-----------------------------------------------
+
+Using the official http://www.libsdl.org/ 1.2.11 release as a basis this
+release aims to add advanced support for the GP2X handheld console/computer.
+
+This libary is part of the Open2x libs project.
+
+ http://wiki.open2x.org/open2x/wiki/index.php?title=Libraries
+ 
+Changes from stock SDL
+----------------------
+
+Added hardware support, made as a seperate video driver rather than
+extending fbcon driver.
+Added ability to scale display surface to full-screen.
+Fixed X & Y buttons.
+Added (partial) hardware cursor support
+Added regions - user-definable areas of the physical display to show.
+Added support for non-scaled displays that are smaller than native resolution.
+Added single USB mouse support.
+Added USB joystick support.
+Added backlight & CPU speed adjustments.
+Added preliminary TV-out control.
+Added option to allow extra 16MB gfx memory
+
+TODO: 
+
+  Cursor support may be flaky on interlaced TV modes.
+  Better control of gfx memory.
+  Lots more
+
+Building:
+---------
+
+You can just install SDL onto most popular GP2X development kits by
+downloading and installing a recent prebuilt library package
+
+ http://wiki.open2x.org/open2x/wiki/index.php?title=Prebuilt_Library_Packages
+ 
+You can also build and install all the libraries by running ./open2x-libs.sh
+from the root libs/ folder. Please review the README.OPEN2X in that folder for 
+more info.
+
+Lastly, you can just build SDL on its own using a configure flag something 
+like what is shown below.
+
+./configure --prefix=$LIB_ROOT --host=$HOST --disable-shared --enable-video-gp2x --enable-video-fbcon=no
+
+
+Using:
+------
+
+This is SDL and can be used just like any other SDL build.
+
+****
+** Limitations of GP2X video driver
+****
+
+The primary surface (as set by SDL_SetVideoMode) is limited to 8 or 16 bit.
+24 and 32 bit modes are NOT supported, driver will use 16bit instead.
+SetVideoMode also forces SDL_HWSURFACE
+
+WARNING: Loading images with IMG_Load(filename) will create SWSURFACES, to
+convert them to HWSURFACES do this:
+
+	img_temp = IMG_Load("my_image.png");
+	img = SDL_DisplayFormat(img_temp);
+	SDL_FreeSurface(img_temp);
+
+Screen sizes can be between 64x64 and 1024x768 inclusive, but the width must
+be a multiple of 8 (legacy), width will be rounded up if need be.
+The primary surface will be visually expanded or shrunk to fill either the
+LCD or TV. The scaler is coarse only, no nice bilinear filtering.
+
+HWSURFACE to HWSURFACE blits are accelerated and ASYNCHRONOUS, SDL_BlitSurface
+will return as soon as it has set the blit up, you MUST lock the surface if
+you want to be sure the blit has taken place.
+
+====
+== SWSURFACE to HWSURFACE blits have moderate acceleration and SDL_BlitSurface
+== will return when the blit is finished, although locking the surface is still
+== required to ensure the blitter flushes its cache.
+===
+== NOTE: My driver supports it, but SDL seems to not call my blit routine if
+== the source surface is SWSURFACE. Will look into it later.
+====
+
+The harware cursor is capable of colour (although only 2), but is 24bit
+regardless of the display surface. It can also alpha-blend it's fore- and
+background colours at different levels, each ranging from 0=transparent to
+15=opaque.
+
+
+****
+** Additional non-standard SDL functions, GP2X specific.
+**
+** These are defined in the non-standard SDL_gp2x.h
+****
+
+////
+int SDL_GP2X_GetPhysicalScreenSize(SDL_Rect *size);
+
+  Fills size->w and size->h with dimensions of the current screen,
+    LCD  : 320x240
+    NTSC : 720x480
+    PAL  : 720x576
+  Returns
+    0 for progressive (LCD)
+    1 for interlaced (NTSC & PAL)
+   -1 if SDL_Init hasn't been called yet
+
+////
+void SDL_GP2X_Display(SDL_Rect *area);
+
+  Sets the hardware scaler to show requested area of primary surface as
+  fullscreen. The scaler does not physically alter the surface, it just
+  affects how the surface will appear on-screen. This allows you to pan
+  around a surface larger than the screen, and/or zoom in/out.
+  You cannot zoom out further than having the full surface on-screen.
+
+  area->x and area->y set which pixel of the primary surface will appear at
+  the top-left corner of the display,
+  area->w and area->h set the width and height of the area to fill the display.
+
+////
+void SDL_GP2X_MiniDisplay(int x, int y);
+
+  Similar to the above function, but does not scale and blanks the borders.
+  Only really useful if your videomode is less than 320x240. Gives rise to
+  possible small speed increase as the display hardware doesn't access
+  memory in the borders. Region 1 (see SDL_GP2X_DefineRegion below) area is
+  set to {x, y, x+videomode_width-1, y+videomodeheight-1}.
+  The x & y values are where the top-left corner of you screen will placed
+  on the display. e.g. for a 200x200 videomode centred in the middle of the
+  display you'd use x=60 y=20
+  NO checking is done to make sure your screen fits!
+
+////
+void SDL_GP2X_SetCursorColour(SDL_Cursor *cursor
+                              int b_red, b_green, b_blue, b_alpha,
+                              int f_red, f_green, f_blue, f_alpha);
+
+  Sets the background and foreground colours of the hardware cursor.
+  SDL assumes black and white for all cursors, this lets you choose
+  your own colours for each cursor. Cursor colours are full 24bit, each
+  component wraps instead of clamping (so if you try setting red to 257
+  you'll actually get 1 etc.)
+  Also, the background and foreground colours have seperate levels of
+  alpha-blending (0=transparent -> 15=opaque). Again, the values wrap.
+
+////
+void SDL_GP2X_DefineRegion(int region, SDL_Rect *area);
+
+  Allows you to define regions (1-4) that will be visible.
+  By default region 1 is set to fullscreen (apart from when using MiniDisplay).
+  Regions work by defining rectangles of the display that the video hardware
+  will show. Think of it like painting your LCD black and for each region
+  you use, scrape the paint off for that rectangle.
+  Region areas are in hardware coordinates, 0x0 is the top-left,
+  319x239 is bottom-right regardless of size and position of your surface.
+
+////
+void SDL_GP2X_ActivateRegion(int region, int activate);
+
+  After defining regions above, use this to switch individual regions
+  on (activate = 1) or off (activate=0).
+  By default only region 1 is active.
+  There is a fifth region, region 5, but this is fullscreen only and hence
+  not available to SDL_GP2X_DefineRegion().
+
+////
+void SDL_SYS_JoystickGp2xSys(SDL_Joystick joystick, int command);
+
+  joystick _must_ be the value returned by SDL_JoystickOpen(0). This is
+  because this function relies on data that is stored in the joystick
+  structure of the internal joystick. To be doing anything on the GP2X
+  you'll more than likely be wanting access to the buttons anyway.
+  The values you can pass as the command are as follows:
+    BACK_LIGHT_OFF	- Switches the backlight off ;)
+    BACK_LIGHT_ON	- Switches the backlight back on.
+    BATT_LED_OFF	- Switches the red battery light on.
+    BATT_LED_ON		- Switches the red battery light off.
+    FCLK_200		- Runs the CPU at 200 MHz.
+    FCLK_166		- Runs the CPU at 166 MHz.
+    FCLK_133		- Runs the CPU at 133 MHz.
+    FCLK_100		- Runs the CPU at 100 MHz.
+    FCLK_78		- Runs the CPU at  78 MHz.
+    FCLK_64		- Runs the CPU at  64 MHz.
+  The following is allowed, but I've just checked the soruce for /dev/gpio to
+  see what speed it corresponded to and found that it doesn't actually do
+  anything.
+    FCLK_DEFAULT	- Runs the CPU at it's default speed.
+
+////
+void SDL_GP2X_TV(int state);  
+
+  Allows user control of TV-Out.
+    state = 0		Internal screen on - TV off.
+    state = 1		TV on - internal screen off
+
+////
+int SDL_GP2X_TVMode(int mode);
+
+  Allows switching of the TV-out chip's mode.
+  Where mode is one of :-
+    DISPLAY_LCD,
+    DISPLAY_MONITOR,
+    DISPLAY_TV_NTSC,
+    DISPLAY_TV_PAL,
+    DISPLAY_TV_GAME_NTSC;
+
+////
+void SDL_GP2X_TVAdjust(int direction);
+
+  Allows adjustment of TV position.
+  Where direction is one of :-
+    TV_POS_LEFT,
+    TV_POS_RIGHT,
+    TV_POS_UP,
+    TV_POS_DOWN;
+
+////
+void SDL_GP2X_AllowGfxMemory(char *start, int size);
+
+  Allows the user to make regions of upper memory available to SDL.
+  Call this function AFTER SDL_Init() but before SDL_SetVideoMode().
+
+  ** Partial implementation
+  ** The values are currently ignored, calling this function will enable
+  ** SDL to use the first 16MB of upper memory in addition to the standard
+  ** 5MB frame buffer. Gfx memory will be 21MB
+
+////
+void SDL_GP2X_DenyGfxMemory(char *start, int size);
+
+  Allows the user to make regions of upper memory unavailable to SDL.
+  Call this function AFTER SDL_Init() but before SDL_SetVideoMode().
+
+  ** Partial implementation
+  ** The values are currently ignored, calling this function will prevent
+  ** SDL from using the first 16MB of upper memory.
+  ** Gfx memory will be the standard 5MB frame buffer.
+
+////
+void SDL_GP2X_VSync();
+
+  Waits for the current frame to be fully displayed.
+  Not needed for double buffered screens.
+
+////
+void *SDL_GP2X_PhysAddress(SDL_Surface *surface);
+
+  Returns the address of the surface's bitmap for use by the 940.
+  Only the hardware and 940 can use the address returned by this function.
+  This function is only valid for hardware surfaces that have been locked
+  with SDL_LockSurface().
+
+  ** NOTE **
+   You must lock the surface first, and after you unlock the surface
+   the pointer that was returned must be considered invalid.
+
+  If the function returns NULL then SDL_GetError() will return one of
+  the following :-
+
+    "Invalid or unlocked surface" - You passed either a null pointer or
+                                    the surface wasn't locked.
+
+    "PhysAddress() only valid for hardware surfaces"
+                                  - You tried getting the address of a
+                                    software surface which the 940 cannot
+                                    access.
+
+*************************************************************
+** The following functions are implemented, but not tested **
+*************************************************************
+
+////
+void SDL_GP2X_SetMonoColours(int background, int foreground);
+  ****
+  ** untested function
+  ****
+  When blitting a 1bpp surface, this sets what colour the 0s and 1s will
+  be translated into. Useful for drawing fonts. 
+  This is a global setting, not per-surface.
+
+-------------------------------------
+
+The Open2x Project
diff -N -rbU5 SDL-1.2.11.orig/src/audio/dsp/SDL_dspaudio.c SDL-1.2.11/src/audio/dsp/SDL_dspaudio.c
--- SDL-1.2.11.orig/src/audio/dsp/SDL_dspaudio.c	2020-04-13 13:02:59.470794713 +0200
+++ SDL-1.2.11/src/audio/dsp/SDL_dspaudio.c	2020-04-13 13:04:39.690689808 +0200
@@ -292,11 +292,12 @@
 	if ( (0x01U<<frag_spec) != spec->size ) {
 		SDL_SetError("Fragment size must be a power of two");
 		DSP_CloseAudio(this);
 		return(-1);
 	}
-	frag_spec |= 0x00020000;	/* two fragments, for low latency */
+	/* frag_spec |= 0x00020000;	*//* two fragments, for low latency */
+	frag_spec |= 0x00100000; /* GP2X Patch, Why is it needed? - DJWillis */
 
 	/* Set the audio buffering parameters */
 #ifdef DEBUG_AUDIO
 	fprintf(stderr, "Requesting %d fragments of size %d\n",
 		(frag_spec >> 16), 1<<(frag_spec&0xFFFF));
diff -N -rbU5 SDL-1.2.11.orig/src/joystick/linux/SDL_sysjoystick.c SDL-1.2.11/src/joystick/linux/SDL_sysjoystick.c
--- SDL-1.2.11.orig/src/joystick/linux/SDL_sysjoystick.c	2020-04-13 13:02:59.472794771 +0200
+++ SDL-1.2.11/src/joystick/linux/SDL_sysjoystick.c	2020-04-13 13:05:01.219311687 +0200
@@ -33,14 +33,19 @@
 #include <linux/joystick.h>
 #if SDL_INPUT_LINUXEV
 #include <linux/input.h>
 #endif
 
+#include "SDL_events.h"
 #include "SDL_joystick.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
 
+/* GP2X Joystick */
+#define GP2X 1
+static const char *SDL_GP2X_JOYSTICK = "GP2X_JOYSTICK";
+
 /* Special joystick configurations */
 static struct {
 	const char *name;
 	int naxes;
 	int nhats;
@@ -268,10 +273,14 @@
 
 
 /* The private structure used to keep track of a joystick */
 struct joystick_hwdata {
 	int fd;
+
+	/* GP2X button states */
+  	unsigned long prev_buttons;
+
 	/* The current linux joystick driver maps hats to two axes */
 	struct hwdata_hat {
 		int axis[2];
 	} *hats;
 	/* The current linux joystick driver maps balls to two axes */
@@ -289,10 +298,51 @@
 		int coef[3];
 	} abs_correct[ABS_MAX];
 #endif
 };
 
+/* Defines for GP2X joystick */
+
+static char *mystrdup(const char *string)
+{
+  char *newstring;
+
+  newstring = (char *)malloc(strlen(string)+1);
+  if (newstring) {
+    strcpy(newstring, string);
+  }
+  return(newstring);
+}
+
+/*  #define MAX_JOYSTICKS  18  */ /* only 2 are supported in the multimedia API */
+#define MAX_AXES        0  /* each joystick can have up to 2 axes */
+#define MAX_BUTTONS    19  /* and 6 buttons                      */
+#define	MAX_HATS        0
+
+#define	JOYNAMELEN      7
+
+#define	PEPC_VK_UP          (1<< 0)
+#define	PEPC_VK_UP_LEFT     (1<< 1)
+#define	PEPC_VK_LEFT        (1<< 2)
+#define	PEPC_VK_DOWN_LEFT   (1<< 3)
+#define	PEPC_VK_DOWN        (1<< 4)
+#define	PEPC_VK_DOWN_RIGHT  (1<< 5)
+#define	PEPC_VK_RIGHT       (1<< 6)
+#define	PEPC_VK_UP_RIGHT    (1<< 7)
+#define	PEPC_VK_START       (1<< 8)
+#define	PEPC_VK_SELECT      (1<< 9)
+#define	PEPC_VK_FL          (1<<10)
+#define	PEPC_VK_FR          (1<<11)
+#define	PEPC_VK_FA          (1<<12)
+#define	PEPC_VK_FB          (1<<13)
+#define	PEPC_VK_FX          (1<<14)
+#define	PEPC_VK_FY          (1<<15)
+#define	PEPC_VK_VOL_UP      (1<<16)
+#define	PEPC_VK_VOL_DOWN    (1<<17)
+#define	PEPC_VK_STICK_PUSH  (1<<18)
+
+static char *gp2x_dev_name = "/dev/GPIO";
 
 #ifndef NO_LOGICAL_JOYSTICKS
 
 static int CountLogicalJoysticks(int max)
 {
@@ -408,11 +458,16 @@
 	char path[PATH_MAX];
 	dev_t dev_nums[MAX_JOYSTICKS];  /* major/minor device numbers */
 	struct stat sb;
 	int n, duplicate;
 
-	numjoysticks = 0;
+	fputs("SDL_SYS_JoystickInit\n", stderr);
+	SDL_joylist[0].fname = mystrdup(SDL_GP2X_JOYSTICK);
+	dev_nums[0] = 0;
+	numjoysticks = 1;
+
+	/* numjoysticks = 0; */
 
 	/* First see if the user specified a joystick to use */
 	if ( SDL_getenv("SDL_JOYSTICK_DEVICE") != NULL ) {
 		SDL_strlcpy(path, SDL_getenv("SDL_JOYSTICK_DEVICE"), sizeof(path));
 		if ( stat(path, &sb) == 0 ) {
@@ -501,10 +556,16 @@
 	int fd;
 	static char namebuf[128];
 	char *name;
 	SDL_logical_joydecl(int oindex = index);
 
+#ifdef GP2X
+	fprintf(stderr, "SDL_GP2X: SYS_JoystickName(%d)\n", index);
+	if (index == 0)
+		return SDL_joylist[0].fname;
+#endif
+
 #ifndef NO_LOGICAL_JOYSTICKS
 	SDL_joylist_head(index, index);
 #endif
 	name = NULL;
 	fd = open(SDL_joylist[index].fname, O_RDONLY, 0);
@@ -529,10 +590,164 @@
 #endif
 	}
 	return name;
 }
 
+/* GP2X Joystick code */
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int SDL_GP2X_JoystickOpen(SDL_Joystick *joystick)
+{
+	int fd;
+
+	fd = open(gp2x_dev_name, O_RDWR | O_NDELAY );
+	if (fd < 0){
+		fputs("GPIO OPEN FAIL\n", stderr);
+	return -1;
+	}
+
+	joystick->hwdata = (struct joystick_hwdata *) malloc(sizeof(*joystick->hwdata));
+	if (joystick->hwdata == NULL) {
+		SDL_OutOfMemory();
+	    return -1;
+	}
+
+	// fill nbuttons, naxes, and nhats fields
+	joystick->nbuttons = MAX_BUTTONS;
+	joystick->naxes = MAX_AXES;
+	joystick->nhats = MAX_HATS;
+
+	joystick->hwdata->fd = fd;
+	joystick->hwdata->prev_buttons = 0;
+
+	return 0;
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+   This function shouldn't update the joystick structure directly,
+   but instead should call SDL_PrivateJoystick*() to deliver events
+   and update joystick device state.
+ */
+
+void SDL_GP2X_JoystickUpdate(SDL_Joystick *joystick)
+{
+	int ret=0;
+	unsigned long buff=0,prev_buttons=0, changed=0;
+
+	ret = read(joystick->hwdata->fd, &buff, 4);
+	prev_buttons = joystick->hwdata->prev_buttons;
+	changed = buff^prev_buttons;
+
+	if (changed & PEPC_VK_UP)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_UP,
+			(buff & PEPC_VK_UP) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_UP_LEFT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_UP_LEFT,
+			(buff & PEPC_VK_UP_LEFT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_LEFT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_LEFT,
+			(buff & PEPC_VK_LEFT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_DOWN_LEFT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_DOWN_LEFT,
+			(buff & PEPC_VK_DOWN_LEFT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_DOWN)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_DOWN,
+			(buff & PEPC_VK_DOWN) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_DOWN_RIGHT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_DOWN_RIGHT,
+			(buff & PEPC_VK_DOWN_RIGHT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_RIGHT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_RIGHT,
+			(buff & PEPC_VK_RIGHT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_UP_RIGHT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_UP_RIGHT,
+			(buff & PEPC_VK_UP_RIGHT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_START)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_START,
+			(buff & PEPC_VK_START) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_SELECT)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_SELECT,
+			(buff & PEPC_VK_SELECT) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FL)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FL,
+			(buff & PEPC_VK_FL) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FR)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FR,
+			(buff & PEPC_VK_FR) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FA)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FA,
+			(buff & PEPC_VK_FA) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FB)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FB,
+			(buff & PEPC_VK_FB) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FX)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FX,
+			(buff & PEPC_VK_FX) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_FY)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_FY,
+			(buff & PEPC_VK_FY) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_VOL_UP)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_VOL_UP,
+			(buff & PEPC_VK_VOL_UP) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_VOL_DOWN)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_VOL_DOWN,
+			(buff & PEPC_VK_VOL_DOWN) ? SDL_PRESSED : SDL_RELEASED);
+
+	if (changed & PEPC_VK_STICK_PUSH)
+		SDL_PrivateJoystickButton(joystick, GP2X_VK_STICK_PUSH,
+			(buff & PEPC_VK_STICK_PUSH) ? SDL_PRESSED : SDL_RELEASED);
+
+	joystick->hwdata->prev_buttons = buff;
+}
+
+/* Backlight and speed control (only here because it's connected to GPIO */
+void SDL_SYS_JoystickGp2xSys(SDL_Joystick *joystick,int cmd)
+{
+	ioctl(joystick->hwdata->fd,IOCTL_GP2X_CONTROL_LIB,cmd);
+}
+
+/* Function to close a joystick after use */
+void SDL_GP2X_JoystickClose(SDL_Joystick *joystick)
+{
+	if (joystick->hwdata != NULL) {
+		close(joystick->hwdata->fd);
+		// free system specific hardware data
+		free(joystick->hwdata);
+	}
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_GP2X_JoystickQuit(void)
+{
+	return;
+}
+
+/* End of GP2X Joystick code */
+
+/******************* Original joystick code ******************/
+
 static int allocate_hatdata(SDL_Joystick *joystick)
 {
 	int i;
 
 	joystick->hwdata->hats = (struct hwdata_hat *)SDL_malloc(
@@ -779,10 +994,14 @@
 {
 	int fd;
 	SDL_logical_joydecl(int realindex);
 	SDL_logical_joydecl(SDL_Joystick *realjoy = NULL);
 
+	/* GP2X internal joystick needs special handling */
+	if (joystick->index == 0)
+		return SDL_GP2X_JoystickOpen(joystick);
+
 	/* Open the joystick and set the joystick file descriptor */
 #ifndef NO_LOGICAL_JOYSTICKS
 	if (SDL_joylist[joystick->index].fname == NULL) {
 		SDL_joylist_head(realindex, joystick->index);
 		realjoy = SDL_JoystickOpen(realindex);
@@ -1134,10 +1353,14 @@
 
 void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
 {
 	int i;
 	
+	/* GP2X internal joystick */
+	if (joystick->index == 0)
+		return SDL_GP2X_JoystickUpdate(joystick);
+
 #if SDL_INPUT_LINUXEV
 	if ( joystick->hwdata->is_hid )
 		EV_HandleEvents(joystick);
 	else
 #endif
@@ -1158,10 +1381,14 @@
 }
 
 /* Function to close a joystick after use */
 void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
 {
+	/* GP2X internal joystick */
+	if (joystick->index == 0)
+		return SDL_GP2X_JoystickClose(joystick);
+
 #ifndef NO_LOGICAL_JOYSTICKS
 	register int i;
 	if (SDL_joylist[joystick->index].fname == NULL) {
 		SDL_joylist_head(i, joystick->index);
 		SDL_JoystickClose(SDL_joylist[i].joy);
diff -N -rbU5 SDL-1.2.11.orig/src/video/ARM_blit1to2.S SDL-1.2.11/src/video/ARM_blit1to2.S
--- SDL-1.2.11.orig/src/video/ARM_blit1to2.S	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/ARM_blit1to2.S	2020-04-13 13:05:16.502753161 +0200
@@ -0,0 +1,82 @@
+@ ARM code version of Blit1to2.
+@
+@ @author Robin Watts (robin@wss.co.uk)
+
+	.text
+
+	.global	Blit1to2ARM
+
+	@ Reads a width x height block of 8 bpp pixels from srcPtr, looks
+	@ them up in the palette at map, and stores them as 16bpp pixels
+	@ at dstPtr. srcPitch and dstPitch give information about how to
+	@ find the next lines.
+Blit1to2ARM:
+	@ r0 = srcPtr
+	@ r1 = srcPitch
+	@ r2 = dstPtr
+	@ r3 = dstPitch
+	MOV	r12,r13
+	STMFD	r13!,{r4-r11,r14}
+	LDMIA	r12,{r4-r6}
+	@ r4 = width
+	@ r5 = height
+	@ r6 = map
+
+	CMP	r7,#0
+	BLE	end
+	SUBS	r5,r5,#1		@ while (--height)
+	BLT	end
+height_loop:
+	SUBS	r7,r4,#5		@ r7= width_minus_5
+	BLE	thin
+width_loop:
+	@ Have to do at least 6 here
+	LDRB	r8, [r0],#1		@ r8 = *src++
+	LDRB	r9, [r0],#1		@ r9 = *src++
+	LDRB	r10,[r0],#1		@ r10= *src++
+	LDRB	r11,[r0],#1		@ r11= *src++
+	LDRB	r12,[r0],#1		@ r12= *src++
+	LDRB	r14,[r0],#1		@ r14= *src++
+	ADD	r8, r8, r8		@ r8 = 2*r8
+	ADD	r9, r9, r9		@ r9 = 2*r9
+	ADD	r10,r10,r10		@ r10= 2*r10
+	ADD	r11,r11,r11		@ r11= 2*r11
+	ADD	r12,r12,r12		@ r12= 2*r12
+	ADD	r14,r14,r14		@ r14= 2*r14
+	LDRH	r8, [r6,r8]		@ r8 = map[r8]
+	LDRH	r9, [r6,r9]		@ r9 = map[r9]
+	LDRH	r10,[r6,r10]		@ r10= map[r10]
+	LDRH	r11,[r6,r11]		@ r11= map[r11]
+	LDRH	r12,[r6,r12]		@ r12= map[r12]
+	LDRH	r14,[r6,r14]		@ r14= map[r14]
+	SUBS	r7,r7,#6		@ r7 = width_minus_5 -= 6
+	STRH	r8, [r2],#2		@ *dstPtr++ = r8
+	STRH	r9, [r2],#2		@ *dstPtr++ = r9
+	STRH	r10,[r2],#2		@ *dstPtr++ = r10
+	STRH	r11,[r2],#2		@ *dstPtr++ = r11
+	STRH	r12,[r2],#2		@ *dstPtr++ = r12
+	STRH	r14,[r2],#2		@ *dstPtr++ = r14
+	BGT	width_loop		@ width_minus_5>0 => 6+ left to do
+thin:
+	ADDS	r7,r7,#5		@ r7 = width (width <= 5)
+	BEQ	end_thin
+thin_lp:
+	LDRB	r8,[r0],#1		@ r8 = *src++
+	SUBS	r7,r7,#1		@ r7 = width--
+	@ Stall
+	ADD	r8,r8,r8		@ r8 = 2*r8
+	LDRH	r8,[r6,r8]		@ r8 = map[r8]
+	@ Stall
+	@ Stall
+	STRH	r8,[r2],#2		@ *dstPtr++ = r8
+	BGT	thin_lp
+end_thin:
+
+	ADD	r2,r2,r3		@ dstPtr += dstPitch
+	ADD	r0,r0,r1		@ srcPtr += srcPitch
+
+	SUBS	r5,r5,#1
+	BGE	height_loop
+
+end:
+	LDMFD	r13!,{r4-r11,PC}
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/gp2x_tslib.c SDL-1.2.11/src/video/gp2x/gp2x_tslib.c
--- SDL-1.2.11.orig/src/video/gp2x/gp2x_tslib.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/gp2x_tslib.c	2020-04-13 13:05:31.924198614 +0200
@@ -0,0 +1,580 @@
+/*
+ * tslib-1.0 based touchscreen event handler
+ *
+ * Altered to work without dynamic loading and fixed modules,
+ * i.e. all code in this file, modules supported are:
+ *   module_raw ucb1x00
+ *   module pthres
+ *   module variance
+ *   module dejitter
+ *
+ * Specifically re-written for HWSDL on the GP2X F-200
+ * changes in functions to remove un-needed stuff like reading >1 value
+ * at a time (SDL only ever reads 1)
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <limits.h>
+#include <string.h>
+
+#include "tslib.h"
+
+typedef struct ts_sample TS_SAMPLE;
+
+typedef struct tslib_vars {
+  const char *name;
+  void *data;
+  int (*fn)(char *str, void *data);
+} TSLIB_VARS;
+
+int tslib_parse_vars(const TSLIB_VARS *, int, const char *);
+
+#define SQR(x) ((x) * (x))
+
+/******************************
+ * tslib open/close
+ ******************************/
+
+TSDEV *ts_open(const char *name, int nonblock)
+{
+  TSDEV *ts;
+  int flags = O_RDONLY;
+
+  if (nonblock)
+    flags |= O_NONBLOCK;
+
+  ts = malloc(sizeof(TSDEV));
+  if (ts) {
+    memset(ts, 0, sizeof(TSDEV));
+
+    ts->fd = open(name, flags);
+    if (ts->fd == -1) {
+      free(ts);
+      ts = NULL;
+    }
+  }
+
+  return ts;
+}
+
+
+
+int ts_close(TSDEV *ts)
+{
+  if (ts)
+  {
+	  if (ts->fd != -1)
+	  {
+  			close(ts->fd);
+			free(ts);
+			return 0;
+	  }
+  }
+
+  return -1;
+}
+
+inline int ts_fd(TSDEV *ts)
+{
+  return ts->fd;
+}
+
+
+/******************************
+ * ucb1x100-raw
+ ******************************/
+
+typedef struct ucb1x00_ts_event {
+  unsigned short pressure;
+  unsigned short x;
+  unsigned short y;
+  unsigned short pad;
+} UCB1X00_TS_EVENT;
+
+//senquack - Originially, I had made this read multiple samples but it turns out the driver
+//for the touchscreen is set up to give only one sample per read, so had to go back
+//to this optimized version.  It should be noted that the device file only ever provides
+//8 bytes of data, basically 3shorts: x,y,and pressure, and the old code tried to read
+//data that was never provided.
+static inline int ucb1x00_read(TSDEV *ts, TS_SAMPLE *samp, int nr)
+{
+	UCB1X00_TS_EVENT ucb1x00_evt;
+
+	//	senquack -trying to solve touchscreen bug
+	if (read(ts->fd, &ucb1x00_evt, sizeof(UCB1X00_TS_EVENT)) == sizeof(UCB1X00_TS_EVENT))
+	{
+		samp->x = ucb1x00_evt.x;
+		samp->y = ucb1x00_evt.y;
+		samp->pressure = ucb1x00_evt.pressure;
+		return 1;
+	} 
+	else
+	{
+		return -1;
+	}
+
+}
+
+
+/******************************
+ * pthres
+ ******************************/
+
+#define MINPRESSURE 35000 // Accepting pressures below this on the GP2X F200 leads to
+									// cursor jumping on taps.
+static inline int pthres_read(TSDEV *ts, TS_SAMPLE *samp, int nr)
+{
+  int ret;
+  static int xsave = 0, ysave = 0;
+  static int press = 0;
+
+  ret = ucb1x00_read(ts, samp,1);
+  if (ret >= 0)
+  {
+		if (samp->pressure < MINPRESSURE)
+		{
+			if (press != 0) {
+				press = 0;
+				samp->pressure = 0;
+				samp->x = xsave;
+				samp->y = ysave;
+				ret = 1;
+			} else {
+				ret = 0;
+			}
+		} else {
+			press = 1;
+			xsave = samp->x;
+			ysave = samp->y;
+			ret = 1;
+		}
+  }
+
+  return ret;
+}
+
+/******************************
+ * variance
+ ******************************/
+
+typedef struct tslib_variance {
+  int       delta;
+  TS_SAMPLE last;
+  TS_SAMPLE noise;
+  unsigned int flags;
+#define VAR_PENDOWN     0x00000001
+#define VAR_LASTVALID   0x00000002
+#define VAR_NOISEVALID  0x00000004
+#define VAR_SUBMITNOISE 0x00000008
+} TSLIB_VARIANCE;
+
+TSLIB_VARIANCE variance_dev;
+
+void variance_init()
+{
+  memset(&variance_dev, 0, sizeof(variance_dev));
+  variance_dev.flags = 0;
+  variance_dev.delta = 30 * 30;
+}
+
+//senquack - added parameter, flush_history, that gets assigned to 1 if a fast movement is
+//			detected.. this is so the averaging algorithm will flush its history if 
+//			enough of them are detected
+static inline int variance_read(TSDEV *ts, TS_SAMPLE *samp, int nr, int *flush_history)
+{
+	struct ts_sample cur;
+	int count = 0, dist;
+
+	while (count < nr) {
+		if (variance_dev.flags & VAR_SUBMITNOISE) {
+			cur = variance_dev.noise;
+			variance_dev.flags &= ~VAR_SUBMITNOISE;
+		} else {
+			if (pthres_read(ts, &cur, 1) < 1)
+				return count;
+		}
+
+		if (cur.pressure == 0) {
+			/* Flush the queue immediately when the pen is just
+			 * released, otherwise the previous layer will
+			 * get the pen up notification too late. This 
+			 * will happen if info->next->ops->read() blocks.
+			 */
+			if (variance_dev.flags & VAR_PENDOWN) {
+				variance_dev.flags |= VAR_SUBMITNOISE;
+				variance_dev.noise = cur;
+			}
+			/* Reset the state machine on pen up events. */
+			variance_dev.flags &= ~(VAR_PENDOWN | VAR_NOISEVALID | VAR_LASTVALID);
+			goto acceptsample;
+		} else
+			variance_dev.flags |= VAR_PENDOWN;
+
+		if (!(variance_dev.flags & VAR_LASTVALID)) {
+			variance_dev.last = cur;
+			variance_dev.flags |= VAR_LASTVALID;
+			continue;
+		}
+
+		if (variance_dev.flags & VAR_PENDOWN) {
+			/* Compute the distance between last sample and current */
+			dist = SQR (cur.x - variance_dev.last.x) +
+			       SQR (cur.y - variance_dev.last.y);
+
+			if (dist > variance_dev.delta) {
+				/* Do we suspect the previous sample was a noise? */
+				if (variance_dev.flags & VAR_NOISEVALID) {
+					/* Two "noises": it's just a quick pen movement */
+					samp [count++] = variance_dev.last = variance_dev.noise;
+					variance_dev.flags = (variance_dev.flags & ~VAR_NOISEVALID) |
+						VAR_SUBMITNOISE;
+
+					//senquack - flush sample history in averaging module
+					*flush_history = 1;
+				} else
+					variance_dev.flags |= VAR_NOISEVALID;
+
+				/* The pen jumped too far, maybe it's a noise ... */
+				variance_dev.noise = cur;
+				continue;
+			} else
+				variance_dev.flags &= ~VAR_NOISEVALID;
+		}
+
+acceptsample:
+//#ifdef DEBUG
+//		fprintf(stderr,"VARIANCE----------------> %d %d %d\n",
+//			var->last.x, var->last.y, var->last.pressure);
+//#endif
+		samp [count++] = variance_dev.last;
+		variance_dev.last = cur;
+	}
+
+	return count;
+}
+
+typedef struct {
+	int x; 
+	int y;
+} XYHIST;
+
+#define XYHISTLENGTH 15
+XYHIST average_xyhist[XYHISTLENGTH];
+
+//senquack - New de-jitterer that can handle high noise level of the GP2X:
+static inline int average_read(TSDEV *ts, TS_SAMPLE *samp, int nr)
+{
+
+	int ret = 0;
+	int newx, newy;
+
+	int flush_history = 0; // variance module will tell us if we are getting fast movements
+	static int flush_count = 0; // when we get enough fast movements, flush the history
+	static int xyhist_full = 0; //senquack - when we have a full four samples, this is 1 
+	static int xyhist_counter = 0; // senquack - how many entires in history?
+	static int xyhist_index = 0;	//xyhist_index - 1 is index to most-recent sample in array
+
+	ret = variance_read(ts, samp, nr, &flush_history);
+	flush_count += flush_history;
+	struct ts_sample *s;
+	s = samp + (ret - 1); // this module can handle more than one sample, but the gp2x
+								// touchscreen driver only ever provides 1 sample each read so
+								// it's not really necessary but not really inefficient either way
+	int i;
+
+	for( i = ret; i > 0; i--, s--) {
+		if ((s->pressure == 0) || (flush_count > 7)) {
+			// when pen is lifted, or a fast movement is detected, flush stored history
+			xyhist_full = 0;
+			xyhist_counter = 0;
+			xyhist_index = 0;
+			flush_count = 0;
+		} else {
+			average_xyhist[xyhist_index].x = s->x;
+			average_xyhist[xyhist_index].y = s->y;
+			
+			xyhist_counter++;
+			if (xyhist_counter == XYHISTLENGTH) {
+				xyhist_full = 1;
+			}
+
+			xyhist_index++;
+			if (xyhist_index == XYHISTLENGTH) {
+				xyhist_index = 0; // point back at beginning since array is full
+			}
+
+			if (xyhist_full) {
+				//we have a full sample history, we can average this sample with the others
+
+				int j = xyhist_index - 1; // point j to most recent entry in history
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}
+
+				// 15-sample weighted average, pyramid, provides great smoothing for precise
+				// operations like menus and drawing
+
+				// sample 1 has weight of * 1
+				newx = average_xyhist[j].x;
+				newy = average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+				
+				// sample 2 has weight of * 2
+				newx += average_xyhist[j].x << 1;
+				newy += average_xyhist[j].y << 1;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 3 has weight of * 3
+				newx += (average_xyhist[j].x << 1) + average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 1) + average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 4 has weight of * 4
+				newx += average_xyhist[j].x << 2;
+				newy += average_xyhist[j].y << 2;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 5 has weight of * 5
+				newx += (average_xyhist[j].x << 2) + average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 2) + average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 6 has weight of * 6
+				newx += (average_xyhist[j].x << 2) + (average_xyhist[j].x << 1);
+				newy += (average_xyhist[j].y << 2) + (average_xyhist[j].y << 1);
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 7 has weight of * 7
+				newx += (average_xyhist[j].x << 3) - average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 3) - average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 8, middle sample,  has weight of * 8
+				newx += (average_xyhist[j].x << 3);
+				newy += (average_xyhist[j].y << 3);
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 9 has weight of * 7
+				newx += (average_xyhist[j].x << 3) - average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 3) - average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 10 has weight of * 6
+				newx += (average_xyhist[j].x << 2) + (average_xyhist[j].x << 1);
+				newy += (average_xyhist[j].y << 2) + (average_xyhist[j].y << 1);
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 11 has weight of * 5
+				newx += (average_xyhist[j].x << 2) + average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 2) + average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 12 has weight of * 4
+				newx += average_xyhist[j].x << 2;
+				newy += average_xyhist[j].y << 2;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+			
+				// sample 13 has weight of * 3
+				newx += (average_xyhist[j].x << 1) + average_xyhist[j].x;
+				newy += (average_xyhist[j].y << 1) + average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 14 has weight of * 2
+				newx += average_xyhist[j].x << 1;
+				newy += average_xyhist[j].y << 1;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+
+				// sample 15 has weight of * 1
+				newx += average_xyhist[j].x;
+				newy += average_xyhist[j].y;
+
+				j--;
+				if (j < 0) {
+					j = XYHISTLENGTH - 1;
+				}		
+				
+				// divide results by 64 to provide average
+				samp->x = newx >> 6;
+				samp->y = newy >> 6;
+			}
+		}
+	}
+
+  return ret;
+}
+
+/******************************
+ * linear
+ ******************************/
+
+typedef struct tslib_linear {
+  int a[7];
+} TSLIB_LINEAR;
+
+TSLIB_LINEAR linear_dev;
+
+void linear_init()
+{
+  struct stat sbuf;
+  int pcal_fd, ret = 0;
+  char pcalbuf[200];
+  int index;
+  char *tokptr;
+  char *calfile=NULL;
+  char *defaultcalfile="/etc/pointercal";
+
+  /* set defaults to typical GP2X values */
+  linear_dev.a[0] = 6203;
+  linear_dev.a[1] = 0;
+  linear_dev.a[2] = -1501397;
+  linear_dev.a[3] = 0;
+  linear_dev.a[4] = -4200;
+  linear_dev.a[5] = 16132680;
+  linear_dev.a[6] = 65536;
+
+	TSLIB_LINEAR tmp_linear_dev;
+	memset(pcalbuf, 0, 200);
+	int got_good_values = 1;	// only when this remains 1 throughout reading of /etc/pointercal will values be accepted into driver
+
+	if ((calfile = getenv("TSLIB_CALIBFILE")) == NULL) calfile = defaultcalfile;
+	if (stat(calfile, &sbuf) == 0) {
+		pcal_fd = open(calfile, O_RDONLY);
+		if (pcal_fd != -1) {
+			int bytes_read = read(pcal_fd, pcalbuf, 200);
+			if (bytes_read > 0) { 
+				tokptr = strtok(pcalbuf, " ");
+				if (tokptr && (isdigit(*tokptr) || (*tokptr == '-'))) {
+					tmp_linear_dev.a[0] = atoi(tokptr);
+					index = 1;
+					while ((index < 7) && got_good_values) {
+						tokptr = strtok(NULL, " ");
+						if (tokptr && (isdigit(*tokptr) || (*tokptr == '-'))) {
+							tmp_linear_dev.a[index] = atoi(tokptr);
+							index++;
+						} else {
+							got_good_values = 0;
+						}
+					}
+				} else {
+					got_good_values = 0;
+				}
+			} else {
+				got_good_values = 0;
+			}
+			
+			close(pcal_fd);
+
+		} else {
+			got_good_values = 0;
+		}
+
+		if (got_good_values) {
+			linear_dev = tmp_linear_dev;
+			fprintf(stderr, "Successfully loaded saved touchscreen calibration values.\n");
+		} else {
+			fprintf(stderr, "Error loading saved touchscreen calibration, using default values\n");
+		}
+  }
+}
+
+static inline int linear_read(TSDEV *ts, TS_SAMPLE *samp, int nr)
+{
+	int ret;
+
+	ret = average_read(ts, samp, nr);
+
+	if (ret > 0) {
+			 if (linear_dev.a[6] == 65536) {
+				samp->x = (linear_dev.a[2] +
+				 linear_dev.a[0] * samp->x) >> 16;
+				samp->y = (linear_dev.a[5] +
+				 linear_dev.a[4] * samp->y) >> 16;
+			 } else {
+				samp->x = (linear_dev.a[2] +
+				 linear_dev.a[0] * samp->x) / linear_dev.a[6];
+				samp->y = (linear_dev.a[5] +
+				 linear_dev.a[4] * samp->y) / linear_dev.a[6];
+			 }
+		}
+
+	return ret;
+}
+
+/******************************
+ * ts_read
+ ******************************/
+
+int ts_read(TSDEV *ts, TS_SAMPLE *samp, int nr)
+{
+	return(linear_read(ts, samp, nr));
+}
+
+
+int ts_config(TSDEV *ts)
+{
+	linear_init();		// read in touchscreen calibration file for proper interpretation of samples
+	variance_init();	// initialize variance module
+	return 0;
+}
+
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/mmsp2_regs.h SDL-1.2.11/src/video/gp2x/mmsp2_regs.h
--- SDL-1.2.11.orig/src/video/gp2x/mmsp2_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/mmsp2_regs.h	2020-04-13 13:05:31.944199191 +0200
@@ -0,0 +1,194 @@
+/*
+ * MMSP2 (MP2520F) Registers
+ *  Only listed needed regs for HW blit stuff
+ *
+ * 2005-12-20 Paeryn
+ */
+  
+
+#ifndef _MMSP2_REG_H_
+#define _MMSP2_REG_H_
+
+/*
+ * Blitter registers
+ */
+
+#define MESGDSTCTRL      (0x0000>>2)
+#define   MESG_DSTENB      (1<<6)
+#define   MESG_BSTBPP       0x60
+#define   MESG_DSTBPP_8    (0<<5)
+#define   MESG_DSTBPP_16   (1<<5)
+
+#define MESGDSTADDR      (0x0004>>2)
+#define MESGDSTSTRIDE    (0x0008>>2)
+#define MESGSRCCTRL      (0x000C>>2)
+#define   MESG_INVIDEO     (1<<8)
+#define   MESG_SRCENB      (1<<7)
+#define   MESG_SRCBPP       0x60
+#define   MESG_SRCBPP_8    (0<<5)
+#define   MESG_SRCBPP_16   (1<<5)
+#define   MESG_SRCBPP_1    (1<<6)
+
+#define MESGSRCADDR      (0x0010>>2)
+#define MESGSRCSTRIDE    (0x0014>>2)
+#define MESGSRCFORCOLOR  (0x0018>>2)
+#define MESGSRCBACKCOLOR (0x001C>>2)
+#define MESGPATCTRL      (0x0020>>2)
+#define   MESG_PATMONO     (1<<6)
+#define   MESG_PATENB      (1<<5)
+#define   MESG_PATBPP       0x18
+#define   MESG_PATBPP_8    (0<<3)
+#define   MESG_PATBPP_16   (1<<3)
+#define   MESG_PATBPP_1    (1<<4)
+#define   MESG_YOFFSET      0x07
+
+#define MESGFORCOLOR     (0x0024>>2)
+#define MESGBACKCOLOR    (0x0028>>2)
+#define MESGSIZE         (0x002C>>2)
+#define   MESG_HEIGHT       16
+#define   MESG_WIDTH         0
+
+#define MESGCTRL         (0x0030>>2)
+#define   MESG_TRANSPCOLOR  16
+#define   MESG_TRANSPEN    (1<<11)
+#define   MESG_FFCLR       (1<<10)
+#define   MESG_YDIR        (1<< 9)
+#define   MESG_YDIR_NEG    (0<< 9)
+#define   MESG_YDIR_POS    (1<< 9)
+#define   MESG_XDIR        (1<< 8)
+#define   MESG_XDIR_NEG    (0<< 8)
+#define   MESG_XDIR_POS    (1<< 8)
+#define   MESG_ROP          0xFF
+
+#define MESGSTATUS       (0x0034>>2)
+#define   MESG_BUSY        (1<<0)
+
+#define MESGFIFOSTATUS   (0x0038>>2)
+#define   MESG_FULL       (1<<31)
+#define   MESG_REMAIN      0x1f
+
+#define MESGFIFO         (0x003C>>2)
+#define MESGPAT          (0x0080>>2)
+
+/*
+ * Basic ROPs
+ */
+#define MESG_ROP_NULL 0xAA
+#define MESG_ROP_COPY 0xCC
+#define MESG_ROP_PAT  0xF0
+
+
+/*
+ * Control registers
+ */
+#define SYSCLKENREG      (0x0904>>1)
+#define   FASTIOCLK        (1<<10)
+
+#define VCLKENREG        (0x090A>>1)
+#define   GRPCLK           (1<<2)
+
+#define SC_STATUS        (0x1802>>1)
+#define   SC_DISP_FIELD    (1<<7)
+
+#define GPIOB_PINLVL     (0x1182>>1)
+#define   GPIOB_VSYNC      (1<<4)
+
+#define DPC_CNTL         (0x2800>>1)
+#define   DPC_INTERLACE    (1<<5)
+#define DPC_X_MAX        (0x2816>>1)
+#define DPC_Y_MAX        (0x2818>>1)
+#define DPC_V_SYNC       (0x2920>>1)
+#define   DPC_VSFLDPOL     (1<<6)
+#define   DPC_VSFLDEN      (1<<7)
+#define DPC_CLKCNTL      (0x2848>>1)
+
+#define MLC_OVLAY_CNTR   (0x2880>>1)
+#define   DISP_BOTH_PATH   (1<<15)
+#define   DISP_OVLY2SCALE  (1<<14)
+#define   DISP_FLD_POL     (1<<13)
+#define   DISP_GAMM_BYPATH (1<<12)
+#define   DISP_SWAP        (1<<11)
+#define   DISP_CURSOR      (1<< 9)
+#define   DISP_SUBPICTURE  (1<< 8)
+#define   DISP_OSD         (1<< 7)
+#define   DISP_STL5EN      (1<< 6)
+#define   DISP_STL4EN      (1<< 5)
+#define   DISP_STL3EN      (1<< 4)
+#define   DISP_STL2EN      (1<< 3)
+#define   DISP_STL1EN      (1<< 2)
+#define   DISP_VLBON       (1<< 1)
+#define   DISP_VLAON       (1<< 0)
+
+#define MLC_STL_CNTL     (0x28DA>>1)
+#define   MLC_STL_BPP       9
+#define   MLC_STL_BPP_4     0x00AA
+#define   MLC_STL_BPP_8     0x02AA
+#define   MLC_STL_BPP_16    0x04AA
+#define   MLC_STL_BPP_24    0x06AA
+#define   MLC_STL5ACT      (1<<8)
+#define   MLC_STL4ACT      (1<<6)
+#define   MLC_STL3ACT      (1<<6)
+#define   MLC_STL2ACT      (1<<4)
+#define   MLC_STL1ACT      (1<<0)
+#define   MLC_STL_DEFAULT   0xAA
+
+#define MLC_STL_MIXMUX   (0x28DC>>1)
+#define   MLC_STL5_MIXMUX   8
+#define   MLC_STL4_MIXMUX   6
+#define   MLC_STL3_MIXMUX   4
+#define   MLC_STL2_MIXMUX   2
+#define   MLC_STL1_MIXMUX   0
+
+#define MLC_STL_ALPHAL   (0x28DE>>1)
+#define   MLC_STL3_ALPHA    8
+#define   MLC_STL2_ALPHA    4
+#define   MLC_STL1_ALPHA    0
+
+#define MLC_STL_ALPHAH   (0x28E0>>1)
+#define   MLC_STL5_ALPHA    4;
+#define   MLC_STL4_ALPHA    0;
+
+#define MLC_STL1_STX     (0x28E2>>1)
+#define MLC_STL1_ENDX    (0x28E4>>1)
+#define MLC_STL1_STY     (0x28E6>>1)
+#define MLC_STL1_ENDY    (0x28E8>>1)
+#define MLC_STL2_STX     (0x28EA>>1)
+#define MLC_STL2_ENDX    (0x28EC>>1)
+#define MLC_STL2_STY     (0x28EE>>1)
+#define MLC_STL2_ENDY    (0x28F0>>1)
+#define MLC_STL3_STX     (0x28F2>>1)
+#define MLC_STL3_ENDX    (0x28F4>>1)
+#define MLC_STL3_STY     (0x28F6>>1)
+#define MLC_STL3_ENDY    (0x28F8>>1)
+#define MLC_STL4_STX     (0x28FA>>1)
+#define MLC_STL4_ENDX    (0x28FC>>1)
+#define MLC_STL4_STY     (0x28FE>>1)
+#define MLC_STL4_ENDY    (0x2900>>1)
+#define MLC_STL_CKEY_GB  (0x2902>>1)
+#define   MLC_STL_CKEYG     8
+#define   MLC_STL_CKEYB     0
+#define MLC_STL_CKEY_R   (0x2904>>1)
+#define MLC_STL_HSC      (0x2906>>1)
+#define MLC_STL_VSCL     (0x2908>>1)
+#define MLC_STL_VSCH     (0x290A>>1)
+#define MLC_STL_HW       (0x290C>>1)
+#define MLC_STL_OADRL    (0x290E>>1)
+#define MLC_STL_OADRH    (0x2910>>1)
+#define MLC_STL_EADRL    (0x2912>>1)
+#define MLC_STL_EADRH    (0x2914>>1)
+#define MLC_STL_PALLT_A  (0x2958>>1)
+#define MLC_STL_PALLT_D  (0x295A>>1)
+
+#define MLC_HWC_CNTL     (0x291E>>1)
+#define MLC_HWC_STX      (0x2920>>1)
+#define MLC_HWC_STY      (0x2922>>1)
+#define MLC_HWC_FGR      (0x2924>>1)
+#define MLC_HWC_FB       (0x2926>>1)
+#define MLC_HWC_BGR      (0x2928>>1)
+#define MLC_HWC_BB       (0x292A>>1)
+#define MLC_HWC_OADRL    (0x292C>>1)
+#define MLC_HWC_OADRH    (0x292E>>1)
+#define MLC_HWC_EADRL    (0x2930>>1)
+#define MLC_HWC_EADRH    (0x2932>>1)
+
+#endif
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xevents.c SDL-1.2.11/src/video/gp2x/SDL_gp2xevents.c
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xevents.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xevents.c	2020-04-13 13:05:31.942199134 +0200
@@ -0,0 +1,1514 @@
+/*
+  SDL - Simple DirectMedia Layer
+  Copyright (C) 1997-2004 Sam Lantinga
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public
+  License along with this library; if not, write to the Free
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+  Sam Lantinga
+  slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+  "@(#) $Id: SDL_gp2xevents.c,v 1.1 2005/10/20 22:19:08 paeryn Exp $";
+#endif
+/* Handle the event stream, converting console events into SDL events */
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+
+/* For parsing /proc */
+#include <dirent.h>
+#include <ctype.h>
+
+#include <linux/vt.h>
+#include <linux/kd.h>
+#include <linux/keyboard.h>
+
+//DKS
+#include <linux/input.h>
+#include "tslib.h"
+
+#include "SDL.h"
+#include "SDL_mutex.h"
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_events_c.h"
+#include "../../events/SDL_sysevents.h"
+#include "SDL_gp2xvideo.h"
+#include "SDL_gp2xevents_c.h"
+ 
+//DKS - uncommented this to match 1.2.9
+#include "SDL_gp2xkeys.h"
+
+//#include "SDL_keysym.h"
+
+//DKS - added for USB keyboard support
+#define tty_fd		this->hidden->keyboard_fd
+
+//DKS - this remains zero until a sample containing a non-zero pressure value has been
+//			read from the touchscreen.  It is a work-around for a bug.  The bug is that
+//			about 10% of the time the touchscreen device is opened, it returns nothing but
+//			zero values until closed and reopened.  Once it starts returning true values, it
+//			never needs to be closed and reopened.  Code uses this flag to see if it should
+//			try to close and reopen the touchscreen device several times a second or so until
+//			it does get good values.
+unsigned int gotten_nonzero_sample = 0;
+
+/***********
+ *** Mouse stuff
+ **********/
+//=====================================================
+// Temporarily enable mouse debug for open/close
+//#define DEBUG_MOUSE 1
+//=====================================================
+
+static enum {
+  MOUSE_NONE = -1,
+  MOUSE_MSC,	/* Note: GPM uses the MSC protocol */
+  MOUSE_PS2,
+  MOUSE_IMPS2,
+  MOUSE_MS,
+  MOUSE_BM,
+  MOUSE_ELO,
+  MOUSE_TSLIB,
+  NUM_MOUSE_DRVS
+} mouse_drv = MOUSE_NONE;
+
+
+//DKS
+//void GP2X_CloseMouse(_THIS)
+//{
+//  if (this->hidden->mouse_fd > 0) {
+//    close(this->hidden->mouse_fd);
+//  }
+//  this->hidden->mouse_fd = -1;
+//}
+void GP2X_CloseMouse(_THIS)
+{
+  if (this->hidden->ts_dev != NULL) {
+    ts_close(this->hidden->ts_dev);
+    this->hidden->ts_dev = NULL;
+    this->hidden->mouse_fd = -1;
+  }
+  if (this->hidden->mouse_fd > 0) {
+    close(this->hidden->mouse_fd);
+  }
+  this->hidden->mouse_fd = -1;
+}
+
+
+/* rcg06112001 Set up IMPS/2 mode, if possible. This gives
+ *  us access to the mousewheel, etc. Returns zero if
+ *  writes to device failed, but you still need to query the
+ *  device to see which mode it's actually in.
+ */
+static int set_imps2_mode(int fd)
+{
+  /* If you wanted to control the mouse mode (and we do :)  ) ...
+     Set IMPS/2 protocol:
+     {0xf3,200,0xf3,100,0xf3,80}
+     Reset mouse device:
+     {0xFF}
+  */
+  Uint8 set_imps2[] = {0xf3, 200, 0xf3, 100, 0xf3, 80};
+  Uint8 reset = 0xff;
+  fd_set fdset;
+  struct timeval tv;
+  int retval = 0;
+
+  if (write(fd, &set_imps2, sizeof(set_imps2)) == sizeof(set_imps2)) {
+    if (write(fd, &reset, sizeof (reset)) == sizeof (reset)) {
+      retval = 1;
+    }
+  }
+
+  /* Get rid of any chatter from the above */
+  FD_ZERO(&fdset);
+  FD_SET(fd, &fdset);
+  tv.tv_sec = 0;
+  tv.tv_usec = 0;
+  while (select(fd+1, &fdset, 0, 0, &tv) > 0) {
+    char temp[32];
+    read(fd, temp, sizeof(temp));
+  }
+
+  return retval;
+}
+
+
+/* Returns true if the mouse uses the IMPS/2 protocol */
+static int detect_imps2(int fd)
+{
+  int imps2;
+
+  imps2 = 0;
+
+  if (getenv("SDL_MOUSEDEV_IMPS2")) {
+    imps2 = 1;
+  }
+  if (!imps2) {
+    Uint8 query_ps2 = 0xF2;
+    fd_set fdset;
+    struct timeval tv;
+
+    /* Get rid of any mouse motion noise */
+    FD_ZERO(&fdset);
+    FD_SET(fd, &fdset);
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+    while (select(fd+1, &fdset, 0, 0, &tv) > 0) {
+      char temp[32];
+      read(fd, temp, sizeof(temp));
+    }
+
+    /* Query for the type of mouse protocol */
+    if (write(fd, &query_ps2, sizeof (query_ps2)) == sizeof (query_ps2)) {
+      Uint8 ch = 0;
+
+      /* Get the mouse protocol response */
+      do {
+	FD_ZERO(&fdset);
+	FD_SET(fd, &fdset);
+	tv.tv_sec = 1;
+	tv.tv_usec = 0;
+	if (select(fd+1, &fdset, 0, 0, &tv) < 1) {
+	  break;
+	}
+      } while ((read(fd, &ch, sizeof (ch)) == sizeof (ch)) &&
+	       ((ch == 0xFA) || (ch == 0xAA)) );
+
+      /* Experimental values (Logitech wheelmouse) */
+#ifdef DEBUG_MOUSE
+      fprintf(stderr, "Last mouse mode: 0x%x\n", ch);
+#endif
+      if ((ch == 3) || (ch == 4)) {
+	imps2 = 1;
+      }
+    }
+  }
+  return imps2;
+}
+
+static struct stat sbuf;
+
+//DKS
+//int GP2X_OpenMouse(_THIS)
+//{
+//  int i;
+//  int touchscreen_fd = -1;
+//  const char *mousedev;
+//  const char *mousedrv;
+//
+//  mousedrv = getenv("SDL_MOUSEDRV");
+//  mousedev = getenv("SDL_MOUSEDEV");
+//  this->hidden->mouse_fd = -1;
+//
+//  /* STD MICE */
+//#ifdef DEBUG_MOUSE
+//  fputs("SDL_GP2X: Looking for a mouse\n", stderr);
+//#endif
+//  if (mousedev == NULL) {
+//    /* FIXME someday... allow multiple mice in this driver */
+//    static const char * const ps2mice[] = {
+//      "/dev/input/mouse/0", "/dev/usbmouse", "/dev/psaux", NULL
+//    };
+//    /* Now try to use a modern PS/2 mouse */
+//    for (i=0; (this->hidden->mouse_fd < 0) && ps2mice[i]; ++i ) {
+//      this->hidden->mouse_fd = open(ps2mice[i], O_RDWR, 0);
+//      if (this->hidden->mouse_fd < 0) {
+//	this->hidden->mouse_fd = open(ps2mice[i], O_RDONLY, 0);
+//      }
+//      if (this->hidden->mouse_fd >= 0) {
+//	/* rcg06112001 Attempt to set IMPS/2 mode */
+//	if (i == 0) {
+//	  set_imps2_mode(this->hidden->mouse_fd);
+//	}
+//	if (detect_imps2(this->hidden->mouse_fd)) {
+//#ifdef DEBUG_MOUSE
+//	  fprintf(stderr, "Using IMPS2 mouse\n");
+//#endif
+//	  mouse_drv = MOUSE_IMPS2;
+//	} else {
+//#ifdef DEBUG_MOUSE
+//	  fprintf(stderr, "Using PS2 mouse\n");
+//#endif
+//	  mouse_drv = MOUSE_PS2;
+//	}
+//	this->hidden->mouse_type = 1; /* GP2X_MOUSE_STD */
+//      }
+//    }
+//    if (this->hidden->mouse_fd < 0) {
+//      touchscreen_fd = open("/dev/touchscreen/wm97xx", O_RDONLY | O_NOCTTY);
+//      if (touchscreen_fd) {
+//	this->hidden->mouse_fd = touchscreen_fd;
+//        read_calibration();
+//	mouse_drv = MOUSE_TSLIB;
+//	this->hidden->mouse_type = 2; /*GP2X_MOUSE_TOUCHSCREEN */
+//#ifdef DEBUG_MOUSE
+//	fputs("SDL_GP2X: F-200 touchscreen emulating mouse\n", stderr);
+//#endif
+//      }
+//    }
+//  }
+//  if (this->hidden->mouse_fd < 0) {
+//    this->hidden->mouse_type = 0; /* GP2X_MOUSE_NONE */
+//    mouse_drv = MOUSE_NONE;
+//#ifdef DEBUG_MOUSE
+//	fputs("SDL_GP2X: No mice found\n", stderr);
+//#endif
+//  }
+//  return this->hidden->mouse_fd;
+//}
+int GP2X_OpenMouse(_THIS)
+{
+  int i;
+  const char *mousedev;
+  const char *mousedrv;
+  
+  mousedrv = getenv("SDL_MOUSEDRV");
+  mousedev = getenv("SDL_MOUSEDEV");
+  this->hidden->mouse_fd = -1;
+  
+  /* STD MICE */
+#ifdef DEBUG_MOUSE
+  fputs("SDL_GP2X: Looking for a mouse\n", stderr);
+#endif
+  if (mousedev == NULL) {
+    /* FIXME someday... allow multiple mice in this driver */
+    static const char * const ps2mice[] = {
+		//      "/dev/input/mouse/0", NULL
+		// DKS - this is actually supposed to me mouse0 not mouse/0
+			"/dev/input/mouse0", NULL
+      //      "/dev/input/mouse/0", "/dev/usbmouse", "/dev/psaux", NULL
+    };
+    /* Now try to use a modern PS/2 mouse */
+    for (i=0; (this->hidden->mouse_fd < 0) && ps2mice[i]; ++i ) {
+      this->hidden->mouse_fd = open(ps2mice[i], O_RDWR, 0);
+      if (this->hidden->mouse_fd < 0) {
+			this->hidden->mouse_fd = open(ps2mice[i], O_RDONLY, 0);
+      }
+      if (this->hidden->mouse_fd >= 0) {
+			/* rcg06112001 Attempt to set IMPS/2 mode */
+			if (i == 0) {
+			  set_imps2_mode(this->hidden->mouse_fd);
+			}
+			if (detect_imps2(this->hidden->mouse_fd)) {
+#ifdef DEBUG_MOUSE
+			  fprintf(stderr, "Using IMPS2 mouse\n");
+#endif
+			  mouse_drv = MOUSE_IMPS2;
+			} else {
+#ifdef DEBUG_MOUSE
+			  fprintf(stderr, "Using PS2 mouse\n");
+#endif
+			  mouse_drv = MOUSE_PS2;
+			}
+				this->hidden->mouse_type = 1; /* GP2X_MOUSE_STD */
+      }
+    }
+    if (this->hidden->mouse_fd < 0) {
+      /* try the F-200 touchscreen */
+      mousedev = "/dev/touchscreen/wm97xx";
+      if (!stat(mousedev, &sbuf)) {
+			this->hidden->ts_dev = ts_open(mousedev, 1);
+			if ((this->hidden->ts_dev != NULL) &&
+			 (ts_config(this->hidden->ts_dev) >= 0)) {
+				  mouse_drv = MOUSE_TSLIB;
+				  this->hidden->mouse_fd = ts_fd(this->hidden->ts_dev);
+				  this->hidden->mouse_type = 2; /*GP2X_MOUSE_TOUCHSCREEN */
+#ifdef DEBUG_MOUSE
+				  fputs("SDL_GP2X: F-200 touchscreen emulating mouse\n", stderr);
+#endif
+			}
+      }
+    }
+  }
+  if (this->hidden->mouse_fd < 0) {
+    this->hidden->mouse_type = 0; /* GP2X_MOUSE_NONE */
+    mouse_drv = MOUSE_NONE;
+#ifdef DEBUG_MOUSE
+    fputs("SDL_GP2X: No mice found\n", stderr);
+#endif
+  }
+  return this->hidden->mouse_fd;
+}
+
+//============================
+#undef DEBUG_MOUSE
+//============================
+
+static int posted = 0;
+
+void GP2X_vgamousecallback(int button, int relative, int dx, int dy)
+{
+  int button_1, button_3;
+  int button_state;
+  int state_changed;
+  int i;
+  Uint8 state;
+
+  //senquack - support for new option to disable mouse motion events from touchscreen
+  if (( dx || dy ) && current_video->hidden->mouse_motion_events_enabled) {
+    posted += SDL_PrivateMouseMotion(0, relative, dx, dy);
+  }
+
+  //senquack - support for new option to disable mouse button events from touchscreen
+	if (current_video->hidden->mouse_button_events_enabled)
+	{
+	  /* Swap button 1 and 3 */
+	  button_1 = (button & 0x04) >> 2;
+	  button_3 = (button & 0x01) << 2;
+	  button &= ~0x05;
+	  button |= (button_1|button_3);
+
+	  /* See what changed */
+	  button_state = SDL_GetMouseState(NULL, NULL);
+	  state_changed = button_state ^ button;
+	  for (i=0; i<8; ++i ) {
+		 if (state_changed & (1<<i)) {
+			if (button & (1<<i)) {
+				state = SDL_PRESSED;
+			} else {
+				state = SDL_RELEASED;
+			}
+			posted += SDL_PrivateMouseButton(state, i+1, 0, 0);
+		 }
+	  }
+	}
+}
+
+//DKS - pulled from my modifications to SDL 1.2.9
+static void handle_tslib(_THIS)
+{
+  struct ts_sample sample;
+  int button;
+
+//DKS - changed this because there's no point sampling higher than 100hz, the driver
+//	doesn't update more often than that
+////  while (ts_read(this->hidden->ts_dev, &sample, 1) > 0) {
+
+  if (ts_read(this->hidden->ts_dev, &sample, 1) > 0) {
+    button = (sample.pressure > 0) ? 1 : 0;
+    button <<= 2;  /* must report it as button 3 */
+    // Store (semi-)raw touchscreen position (pre mouse clipping)
+    this->hidden->touch_x = sample.x;
+    this->hidden->touch_y = sample.y;
+    this->hidden->touch_pressure = sample.pressure;
+
+	 //DKS - once we have gotten a valid sample from the touchscreen, this flag tells 
+	 // 	handle_mouse to stop trying to reopen the mouse device every second or so
+	 // 	so as a workaround fora non-responsive device file.	
+	 if ( sample.pressure > 0 )
+	 {
+		gotten_nonzero_sample = 1;
+	 }
+
+    sample.x = ((sample.x * this->hidden->invxscale) >> 16) +
+               this->hidden->x_offset;
+    sample.y = ((sample.y * this->hidden->invyscale) >> 16) +
+               this->hidden->y_offset;
+    GP2X_vgamousecallback(button, 0, sample.x, sample.y);
+  }  
+  return;
+}
+
+/* For now, use MSC, PS/2, and MS protocols
+   Driver adapted from the SVGAlib mouse driver code (taken from gpm, etc.)
+*/
+//DKS - pulled newer version from better 1.2.9 code
+//static void handle_mouse(_THIS)
+//{
+//  static int start = 0;
+//  static unsigned char mousebuf[BUFSIZ];
+//  static int relative = 1;
+//  TS_EVENT *ts_event;
+//
+//  int i, nread;
+//  int button = 0;
+//  int dx = 0, dy = 0;
+//  int packetsize = 0;
+//  int realx, realy;
+//
+//  /* Figure out the mouse packet size */
+//  switch (mouse_drv) {
+//  case MOUSE_NONE:
+//    /* Ack! */
+//    read(this->hidden->mouse_fd, mousebuf, BUFSIZ);
+//    return;
+//  case MOUSE_MSC:
+//    packetsize = 5;
+//    break;
+//  case MOUSE_IMPS2:
+//    packetsize = 4;
+//    break;
+//  case MOUSE_PS2:
+//  case MOUSE_MS:
+//  case MOUSE_BM:
+//    packetsize = 3;
+//    break;
+//  case MOUSE_ELO:
+//    packetsize = 0;
+//    break;
+//  case MOUSE_TSLIB:
+//    packetsize= sizeof(TS_EVENT);
+//    break;
+//  case NUM_MOUSE_DRVS:
+//    /* Uh oh.. */
+//    packetsize = 0;
+//    break;
+//  }
+//
+//  /* Read as many packets as possible */
+//  nread = read(this->hidden->mouse_fd, &mousebuf[start], BUFSIZ-start);
+//  if (nread < 0) {
+//    return;
+//  }
+//  nread += start;
+//#ifdef DEBUG_MOUSE
+//  fprintf(stderr, "Read %d bytes from mouse, start = %d\n", nread, start);
+//#endif
+//  for (i=0; i<(nread-(packetsize-1)); i += packetsize) {
+//    switch (mouse_drv) {
+//    case MOUSE_NONE:
+//      break;
+//    case MOUSE_MSC:
+//      /* MSC protocol has 0x80 in high byte */
+//      if ((mousebuf[i] & 0xF8) != 0x80) {
+//	/* Go to next byte */
+//	i -= (packetsize-1);
+//	continue;
+//      }
+//      /* Get current mouse state */
+//      button = (~mousebuf[i]) & 0x07;
+//      dx =   (signed char)(mousebuf[i+1]) +
+//	(signed char)(mousebuf[i+3]);
+//      dy = -((signed char)(mousebuf[i+2]) +
+//	     (signed char)(mousebuf[i+4]));
+//      relative = 1;
+//      break;
+//    case MOUSE_PS2:
+//      /* PS/2 protocol has nothing in high byte */
+//      if ((mousebuf[i] & 0xC0) != 0) {
+//	/* Go to next byte */
+//	i -= (packetsize-1);
+//	continue;
+//      }
+//      /* Get current mouse state */
+//      button = (mousebuf[i] & 0x04) >> 1 | /*Middle*/
+//	(mousebuf[i] & 0x02) >> 1 | /*Right*/
+//	(mousebuf[i] & 0x01) << 2;  /*Left*/
+//      dx = (mousebuf[i] & 0x10) ?
+//	mousebuf[i+1] - 256 : mousebuf[i+1];
+//      dy = (mousebuf[i] & 0x20) ?
+//	-(mousebuf[i+2] - 256) : -mousebuf[i+2];
+//      relative = 1;
+//      break;
+//    case MOUSE_IMPS2:
+//      /* Get current mouse state */
+//      button = (mousebuf[i] & 0x04) >> 1 | /*Middle*/
+//	(mousebuf[i] & 0x02) >> 1 | /*Right*/
+//	(mousebuf[i] & 0x01) << 2 | /*Left*/
+//	(mousebuf[i] & 0x40) >> 3 | /* 4 */
+//	(mousebuf[i] & 0x80) >> 3;  /* 5 */
+//      dx = (mousebuf[i] & 0x10) ?
+//	mousebuf[i+1] - 256 : mousebuf[i+1];
+//      dy = (mousebuf[i] & 0x20) ?
+//	-(mousebuf[i+2] - 256) : -mousebuf[i+2];
+//      switch (mousebuf[i+3]&0x0F) {
+//      case 0x0E: /* DX = +1 */
+//      case 0x02: /* DX = -1 */
+//	break;
+//      case 0x0F: /* DY = +1 (map button 4) */
+//	GP2X_vgamousecallback(button | (1<<3),
+//			      1, 0, 0);
+//	break;
+//      case 0x01: /* DY = -1 (map button 5) */
+//	GP2X_vgamousecallback(button | (1<<4),
+//			      1, 0, 0);
+//	break;
+//      }
+//      break;
+//    case MOUSE_MS:
+//    case MOUSE_BM:
+//    case MOUSE_ELO:
+//      dx = 0;
+//      dy = 0;
+//      break;
+//    case MOUSE_TSLIB:
+//      ts_event = (TS_EVENT*)mousebuf;
+//      button = (ts_event->pressure ? 0x04 : 0x00);
+//      if (ts_cal[6] == 65536) {   // This seems to be what the F200 uses
+//	dx = (ts_cal[2] + ts_cal[0] * (int)ts_event->x) >> 16;
+//	dy = (ts_cal[5] + ts_cal[4] * (int)ts_event->y) >> 16;
+//      } else {
+//	dx = (ts_cal[2] + ts_cal[0] * (int)ts_event->x) / ts_cal[6];
+//	dy = (ts_cal[5] + ts_cal[4] * (int)ts_event->y) / ts_cal[6];
+//      }
+//      /*
+//      fprintf(stderr, "GP2X_TS: button %d, pos %d,%d\n", button, dx ,dy);
+//      */
+//      if ((dx <0) || (dx > 320) || (dy < 0) || (dy > 240)) {
+//	dx = dy = 0;
+//	relative = 1;
+//      } else {
+//	relative = 0;
+//	dx = ((dx * this->hidden->invxscale) >> 16) + this->hidden->x_offset;
+//	dy = ((dy * this->hidden->invyscale) >> 16) + this->hidden->y_offset;
+//      }
+//      break;
+//    case NUM_MOUSE_DRVS:
+//      /* Uh oh.. */
+//      dx = 0;
+//      dy = 0;
+//      break;
+//    }
+//    GP2X_vgamousecallback(button, relative, dx, dy);
+//  }
+//  if ( i < nread ) {
+//    memcpy(mousebuf, &mousebuf[i], (nread-i));
+//    start = (nread-i);
+//  } else {
+//    start = 0;
+//  }
+//  return;
+//}
+static void handle_mouse(_THIS)
+{
+  static int start = 0;
+  static unsigned char mousebuf[BUFSIZ];
+  static int relative = 1;
+
+  int i, nread;
+  int button = 0;
+  int dx = 0, dy = 0;
+  int packetsize = 0;
+
+  //DKS for determining if we should read the touchscreen or wait some more
+	static struct timeval lastread = { 0, 0 };
+	static struct timeval now = { 0, 0 };
+	unsigned int sample_interval;
+	static unsigned int touchscreen_reopen_ctr = 0;
+
+  /* Figure out the mouse packet size */
+  switch (mouse_drv) {
+  case MOUSE_NONE:
+    /* Ack! */
+    read(this->hidden->mouse_fd, mousebuf, BUFSIZ);
+    return;
+  case MOUSE_MSC:
+    packetsize = 5;
+    break;
+  case MOUSE_IMPS2:
+    packetsize = 4;
+    break;
+  case MOUSE_PS2:
+  case MOUSE_MS:
+  case MOUSE_BM:
+    packetsize = 3;
+    break;
+  case MOUSE_ELO:
+    packetsize = 0;
+    break;
+  case MOUSE_TSLIB:
+	//DKS we want to limit the frequency with which the touchscreen is read, as it never
+	//data faster than 100hz anyways.
+#define TSLIB_INTERVAL 5000 	// every 5 ms, which allows us to capture all events but
+	 									// not waste cycles 
+		gettimeofday(&now, NULL);
+		sample_interval = (now.tv_sec * 1000000 + now.tv_usec) -
+									(lastread.tv_sec * 1000000 + lastread.tv_usec);
+
+
+		if ( !gotten_nonzero_sample && touchscreen_reopen_ctr >= 100)
+		{
+			// We are running on a GP2X with touchscreen, but we have not gotten 
+			// a sample with non-zero pressure yet.  This workaround will continue
+			// to try to close and reopen the touchscreen device every second or so
+			// until we get a non-zero sample.  Once we do, don't worry about it as
+			// the unit should be OK after that.  Once a second or so should not cause
+			// too much overhead for games not using the touchscreen.
+
+#ifdef DEBUG_MOUSE
+			fprintf(stderr, "SDL_GP2X: Not gotten good F200 touchscreen sample yet.\n\t\tReopening device just in case.\n");
+#endif
+			ts_close(this->hidden->ts_dev);
+			this->hidden->ts_dev = ts_open("/dev/touchscreen/wm97xx", 1);
+			this->hidden->mouse_fd = this->hidden->ts_dev->fd;
+			touchscreen_reopen_ctr = 0;
+		}
+
+		if (sample_interval > TSLIB_INTERVAL)
+		{
+			// 5ms has passed, read a touchscreen sample
+			handle_tslib(this);
+			gettimeofday(&lastread, NULL);
+			if (!gotten_nonzero_sample)
+			{
+				touchscreen_reopen_ctr++;			
+			}
+		} else {
+			dx = 0;
+			dy = 0;
+		}
+
+//    handle_tslib(this);
+    return; /* nothing left to do */
+  case NUM_MOUSE_DRVS:
+    /* Uh oh.. */
+    packetsize = 0;
+    break;
+  }
+
+  /* Read as many packets as possible */
+  nread = read(this->hidden->mouse_fd, &mousebuf[start], BUFSIZ-start);
+  if (nread < 0) {
+    return;
+  }
+  nread += start;
+#ifdef DEBUG_MOUSE
+  fprintf(stderr, "Read %d bytes from mouse, start = %d\n", nread, start);
+#endif
+  for (i=0; i<(nread-(packetsize-1)); i += packetsize) {
+    switch (mouse_drv) {
+    case MOUSE_NONE:
+      break;
+    case MOUSE_MSC:
+      /* MSC protocol has 0x80 in high byte */
+      if ((mousebuf[i] & 0xF8) != 0x80) {
+	/* Go to next byte */
+	i -= (packetsize-1);
+	continue;
+      }
+      /* Get current mouse state */
+      button = (~mousebuf[i]) & 0x07;
+      dx =   (signed char)(mousebuf[i+1]) +
+	(signed char)(mousebuf[i+3]);
+      dy = -((signed char)(mousebuf[i+2]) +
+	     (signed char)(mousebuf[i+4]));
+      relative = 1;
+      break;
+    case MOUSE_PS2:
+      /* PS/2 protocol has nothing in high byte */
+      if ((mousebuf[i] & 0xC0) != 0) {
+	/* Go to next byte */
+	i -= (packetsize-1);
+	continue;
+      }
+      /* Get current mouse state */
+      button = (mousebuf[i] & 0x04) >> 1 | /*Middle*/
+	(mousebuf[i] & 0x02) >> 1 | /*Right*/
+	(mousebuf[i] & 0x01) << 2;  /*Left*/
+      dx = (mousebuf[i] & 0x10) ?
+	mousebuf[i+1] - 256 : mousebuf[i+1];
+      dy = (mousebuf[i] & 0x20) ?
+	-(mousebuf[i+2] - 256) : -mousebuf[i+2];
+      relative = 1;
+      break;
+    case MOUSE_IMPS2:
+      /* Get current mouse state */
+      button = (mousebuf[i] & 0x04) >> 1 | /*Middle*/
+	(mousebuf[i] & 0x02) >> 1 | /*Right*/
+	(mousebuf[i] & 0x01) << 2 | /*Left*/
+	(mousebuf[i] & 0x40) >> 3 | /* 4 */
+	(mousebuf[i] & 0x80) >> 3;  /* 5 */
+      dx = (mousebuf[i] & 0x10) ?
+	mousebuf[i+1] - 256 : mousebuf[i+1];
+      dy = (mousebuf[i] & 0x20) ?
+	-(mousebuf[i+2] - 256) : -mousebuf[i+2];
+      switch (mousebuf[i+3]&0x0F) {
+      case 0x0E: /* DX = +1 */
+      case 0x02: /* DX = -1 */
+	break;
+      case 0x0F: /* DY = +1 (map button 4) */
+	GP2X_vgamousecallback(button | (1<<3),
+			      1, 0, 0);
+	break;
+      case 0x01: /* DY = -1 (map button 5) */
+	GP2X_vgamousecallback(button | (1<<4),
+			      1, 0, 0);
+	break;
+      }
+      break;
+    case MOUSE_MS:
+    case MOUSE_BM:
+    case MOUSE_ELO:
+      dx = 0;
+      dy = 0;
+      break;
+    case MOUSE_TSLIB:
+    case NUM_MOUSE_DRVS:
+      /* Uh oh.. */
+      dx = 0;
+      dy = 0;
+      break;
+    }
+    GP2X_vgamousecallback(button, relative, dx, dy);
+  }
+  if ( i < nread ) {
+    memcpy(mousebuf, &mousebuf[i], (nread-i));
+    start = (nread-i);
+  } else {
+    start = 0;
+  }
+  return;
+}
+
+/* The translation tables from a console scancode to a SDL keysym */
+#define NUM_VGAKEYMAPS	(1<<KG_CAPSSHIFT)
+static Uint16 vga_keymap[NUM_VGAKEYMAPS][NR_KEYS];
+static SDLKey keymap[128];
+static Uint16 keymap_temp[128]; /* only used at startup */
+static SDL_keysym *TranslateKey(int scancode, SDL_keysym *keysym);
+
+//DKS - new stuff for USB keyboard
+static int GP2X_SetRawKeyboardMode(_THIS);
+static void GP2X_SetPreviousKeyboardMode(_THIS);
+static int GP2X_InRawKeyboardMode(_THIS);
+
+//DKS - pulled from 1.2.9's newer USB keyboard support I added
+int GP2X_InRawKeyboardMode(_THIS)
+{
+	return((tty_fd >= 0) && (this->hidden->saved_kbd_mode >= 0));
+}
+
+//DKS - pulled this from virgin 1.2.9 SDL fbcon 
+int GP2X_SetRawKeyboardMode(_THIS)
+{
+	struct termios keyboard_termios;
+
+	/* Set medium-raw keyboard mode */
+	if ( (tty_fd >= 0) && !GP2X_InRawKeyboardMode(this) ) {
+
+//DKS - don't need this on GP2X
+//		/* Switch to the correct virtual terminal */
+//		if ( current_vt > 0 ) {
+//			struct vt_stat vtstate;
+//
+//			if ( ioctl(keyboard_fd, VT_GETSTATE, &vtstate) == 0 ) {
+//				saved_vt = vtstate.v_active;
+//			}
+//			if ( ioctl(keyboard_fd, VT_ACTIVATE, current_vt) == 0 ) {
+//				ioctl(keyboard_fd, VT_WAITACTIVE, current_vt);
+//			}
+//		}
+
+		/* Set the terminal input mode */
+		if ( tcgetattr(tty_fd, &(this->hidden->saved_kbd_termios)) < 0 ) {
+			SDL_SetError("Unable to get terminal attributes");
+			if ( tty_fd > 0 ) {
+				close(tty_fd);
+			}
+			tty_fd = -1;
+			return(-1);
+		}
+		if ( ioctl(tty_fd, KDGKBMODE, &(this->hidden->saved_kbd_mode)) < 0 ) {
+			SDL_SetError("Unable to get current keyboard mode");
+			if ( tty_fd > 0 ) {
+				close(tty_fd);
+			}
+			tty_fd = -1;
+			return(-1);
+		}
+		keyboard_termios = this->hidden->saved_kbd_termios;
+		keyboard_termios.c_lflag &= ~(ICANON | ECHO | ISIG);
+		keyboard_termios.c_iflag &= ~(ISTRIP | IGNCR | ICRNL | INLCR | IXOFF | IXON);
+		keyboard_termios.c_cc[VMIN] = 0;
+		keyboard_termios.c_cc[VTIME] = 0;
+		if (tcsetattr(tty_fd, TCSAFLUSH, &keyboard_termios) < 0) {
+			GP2X_CloseKeyboard(this);
+			SDL_SetError("Unable to set terminal attributes");
+			return(-1);
+		}
+		/* This will fail if we aren't root or this isn't our tty */
+		if ( ioctl(tty_fd, KDSKBMODE, K_MEDIUMRAW) < 0 ) {
+			GP2X_CloseKeyboard(this);
+			SDL_SetError("Unable to set keyboard in raw mode");
+			return(-1);
+		}
+		if ( ioctl(tty_fd, KDSETMODE, KD_GRAPHICS) < 0 ) {
+			GP2X_CloseKeyboard(this);
+			SDL_SetError("Unable to set keyboard in graphics mode");
+			return(-1);
+		}
+	}
+	return(tty_fd);
+
+}
+
+//DKS - pulled from GPH's code
+void GP2X_SetPreviousKeyboardMode(_THIS)
+{
+	if(!GP2X_InRawKeyboardMode(this))
+		return;
+
+	if (tty_fd >= 0) {
+		ioctl(tty_fd, KDSETMODE, KD_TEXT);
+		ioctl(tty_fd, KDSKBMODE, this->hidden->saved_kbd_mode);
+		tcsetattr(tty_fd, TCSAFLUSH, &(this->hidden->saved_kbd_termios));
+	}
+
+	this->hidden->saved_kbd_mode = -1;
+}
+
+/* Ugh, we have to duplicate the kernel's keysym mapping code...
+   Oh, it's not so bad. :-)
+
+   FIXME: Add keyboard LED handling code
+*/
+static void GP2X_vgainitkeymaps(int fd)
+{
+  struct kbentry entry;
+  int map, i;
+
+  /* Don't do anything if we are passed a closed keyboard */
+  if (fd < 0) {
+    return;
+  }
+
+  /* Load all the keysym mappings */
+  for (map=0; map<NUM_VGAKEYMAPS; ++map) {
+    memset(vga_keymap[map], 0, NR_KEYS*sizeof(Uint16));
+
+    for (i = 0; i < NR_KEYS; ++i) {
+      entry.kb_table = map;
+      entry.kb_index = i;
+      if (ioctl(fd, KDGKBENT, &entry) == 0) {
+	/* fill keytemp. This replaces SDL_fbkeys.h */
+	if ((map == 0) && (i<128)) {
+	  keymap_temp[i] = entry.kb_value;
+	}
+	/* The "Enter" key is a special case */
+	if (entry.kb_value == K_ENTER) {
+	  entry.kb_value = K(KT_ASCII,13);
+	}
+	/* Handle numpad specially as well */
+	if (KTYP(entry.kb_value) == KT_PAD) {
+	  switch (entry.kb_value) {
+	  case K_P0:
+	  case K_P1:
+	  case K_P2:
+	  case K_P3:
+	  case K_P4:
+	  case K_P5:
+	  case K_P6:
+	  case K_P7:
+	  case K_P8:
+	  case K_P9:
+	    vga_keymap[map][i]=entry.kb_value;
+	    vga_keymap[map][i]+= '0';
+	    break;
+	  case K_PPLUS:
+	    vga_keymap[map][i]=K(KT_ASCII,'+');
+	    break;
+	  case K_PMINUS:
+	    vga_keymap[map][i]=K(KT_ASCII,'-');
+	    break;
+	  case K_PSTAR:
+	    vga_keymap[map][i]=K(KT_ASCII,'*');
+	    break;
+	  case K_PSLASH:
+	    vga_keymap[map][i]=K(KT_ASCII,'/');
+	    break;
+	  case K_PENTER:
+	    vga_keymap[map][i]=K(KT_ASCII,'\r');
+	    break;
+	  case K_PCOMMA:
+	    vga_keymap[map][i]=K(KT_ASCII,',');
+	    break;
+	  case K_PDOT:
+	    vga_keymap[map][i]=K(KT_ASCII,'.');
+	    break;
+	  default:
+	    break;
+	  }
+	}
+	/* Do the normal key translation */
+	if ((KTYP(entry.kb_value) == KT_LATIN) ||
+	    (KTYP(entry.kb_value) == KT_ASCII) ||
+	    (KTYP(entry.kb_value) == KT_LETTER)) {
+	  vga_keymap[map][i] = entry.kb_value;
+	}
+      }
+    }
+  }
+}
+
+//DKS - not used anymore
+//int GP2X_InGraphicsMode(_THIS)
+//{
+//  return ((keyboard_fd >= 0) && (saved_kbd_mode >= 0));
+//}
+
+//DKS - not used anymore
+//int GP2X_EnterGraphicsMode(_THIS)
+//{
+//  struct termios keyboard_termios;
+//
+//  /* Set medium-raw keyboard mode */
+//  if ((keyboard_fd >= 0) && !GP2X_InGraphicsMode(this)) {
+//
+//    /* Set the terminal input mode */
+//    if (tcgetattr(keyboard_fd, &saved_kbd_termios) < 0) {
+//      SDL_SetError("Unable to get terminal attributes");
+//      if (keyboard_fd > 0) {
+//	close(keyboard_fd);
+//      }
+//      keyboard_fd = -1;
+//      return(-1);
+//    }
+//    keyboard_termios = saved_kbd_termios;
+//
+//    keyboard_termios.c_lflag = 0;
+//    keyboard_termios.c_iflag &= ~(ISTRIP | IGNCR | ICRNL | INLCR | IXOFF | IXON);
+//
+//    keyboard_termios.c_cc[VTIME]    = 0;   //   timer disable
+//    keyboard_termios.c_cc[VMIN]     = 1;   //  5    blocking
+//
+//    tcflush(keyboard_fd, TCIFLUSH);
+//
+//    if (tcsetattr(keyboard_fd, TCSAFLUSH, &keyboard_termios) < 0) {
+//      GP2X_CloseKeyboard(this);
+//      SDL_SetError("Unable to set terminal attributes");
+//      return(-1);
+//    }
+//
+//
+//  }
+//  return(keyboard_fd);
+//}
+
+//DKS - not used anymore
+//void GP2X_LeaveGraphicsMode(_THIS)
+//{
+//  tcsetattr(keyboard_fd, TCSAFLUSH, &saved_kbd_termios);
+//  saved_kbd_mode = -1;
+//}
+
+//DKS - changed to newer function from after I completed the USB keyboard support in 1.2.9
+//int GP2X_OpenKeyboard(_THIS)
+//{
+//  /* Open only if not already opened */
+//  if ( keyboard_fd < 0 ) {
+//    static const char * const tty0[] = { "/dev/tty0", "/dev/vc/0", NULL };
+//    static const char * const vcs[] = { "/dev/vc/%d", "/dev/tty%d", NULL };
+//    int i, tty0_fd;
+//
+//    /* Try to query for a free virtual terminal */
+//    tty0_fd = -1;
+//    for (i = 0; tty0[i] && (tty0_fd < 0); ++i) {
+//      tty0_fd = open(tty0[i], O_WRONLY, 0);
+//    }
+//
+//    if ( keyboard_fd < 0 ) {
+//      /* Last resort, maybe our tty is a usable VT */
+//      current_vt = 0;
+//      keyboard_fd = open("/dev/tty", O_RDWR);
+//    }
+//#ifdef DEBUG_KEYBOARD
+//    fprintf(stderr, "Current VT: %d\n", current_vt);
+//#endif
+//    saved_kbd_mode = -1;
+//
+//  }
+//  return(keyboard_fd);
+//}
+//DKS - pulled from GPH's code
+int GP2X_OpenKeyboard(_THIS)
+{
+	//DKS - it should be noted tty_fd is really an alias for keyboard_fd, and keyboard_fd
+	// is an int buried in SDL_gp2xvideo.c
+
+	/* Open only if not already opened */
+ 	if ( tty_fd < 0 ) {
+		static const char * const tty0[] = { "/dev/tty0", "/dev/vc/0", NULL };
+		int i;
+
+		/* Try to query for a free virtual terminal */
+		tty_fd = -1;
+		for ( i=0; tty0[i] && (tty_fd < 0); ++i ) {
+			tty_fd = open(tty0[i],  O_RDWR | O_NDELAY, 0);
+		}
+
+		if(tty_fd >= 0) {
+			/* Set up keymap */
+			GP2X_vgainitkeymaps(tty_fd);
+		}
+
+ 		this->hidden->saved_kbd_mode = -1;
+		
+		GP2X_SetRawKeyboardMode(this);
+ 	}
+
+ 	return(tty_fd);
+}
+
+//DKS - changed to newer function from after I completed the USB keyboard support in 1.2.9
+//void GP2X_CloseKeyboard(_THIS)
+//{
+//  if (keyboard_fd >= 0) {
+//    GP2X_LeaveGraphicsMode(this);
+//    if (keyboard_fd > 0) {
+//      close(keyboard_fd);
+//    }
+//  }
+//  keyboard_fd = -1;
+//}
+void GP2X_CloseKeyboard(_THIS)
+{
+	if ( tty_fd >= 0 ) {
+		GP2X_SetPreviousKeyboardMode(this);
+		if ( tty_fd >= 0 ) close(tty_fd);
+	}
+	tty_fd = -1;
+}
+
+
+//DKS - changed to newer function from after I completed the USB keyboard support in 1.2.9
+//static void handle_keyboard(_THIS)
+//{
+//  unsigned char keybuf[BUFSIZ];
+//  int i, nread;
+//  int pressed;
+//  int scancode;
+//  SDL_keysym keysym;
+//
+//  nread = read(keyboard_fd, keybuf, BUFSIZ);
+//
+//  // ghcstop add: 041206      .
+//  if (nread >= 3) return;
+//
+//  for (i = 0; i<nread; ++i) {
+//    scancode = keybuf[i] & 0x7F;
+//    if (keybuf[i] & 0x80) {
+//      pressed = SDL_RELEASED;
+//    } else {
+//      pressed = SDL_PRESSED;
+//    }
+//    TranslateKey(scancode, &keysym);
+//
+//    /* Handle Alt-FN for vt switch */
+//    switch (keysym.sym) {
+//    case SDLK_F1:
+//    case SDLK_F2:
+//    case SDLK_F3:
+//    case SDLK_F4:
+//    case SDLK_F5:
+//    case SDLK_F6:
+//    case SDLK_F7:
+//    case SDLK_F8:
+//    case SDLK_F9:
+//    case SDLK_F10:
+//    case SDLK_F11:
+//    case SDLK_F12:
+//      if (SDL_GetModState() & KMOD_ALT) {
+//	if (pressed) {
+//	  switch_vt(this, (keysym.sym-SDLK_F1)+1);
+//	}
+//	break;
+//      }
+//      /* Fall through to normal processing */
+//    default:
+//      posted += SDL_PrivateKeyboard(pressed, &keysym);
+//      break;
+//    }
+//  }
+//}
+//DKS - pulled from virgin SDL fbcon/  and modified
+static void handle_keyboard(_THIS)
+{
+	unsigned char keybuf[BUFSIZ];
+	int i, nread;
+	int pressed;
+	int scancode;
+	SDL_keysym keysym;
+
+	nread = read(tty_fd, keybuf, BUFSIZ);
+	for ( i=0; i<nread; ++i ) {
+		scancode = keybuf[i] & 0x7F;
+		if ( keybuf[i] & 0x80 ) {
+			pressed = SDL_RELEASED;
+		} else {
+			pressed = SDL_PRESSED;
+		}
+		TranslateKey(scancode, &keysym);
+//DKS - on GP2X, no virtual terminals
+//		/* Handle Alt-FN for vt switch */
+//		switch (keysym.sym) {
+//		    case SDLK_F1:
+//		    case SDLK_F2:
+//		    case SDLK_F3:
+//		    case SDLK_F4:
+//		    case SDLK_F5:
+//		    case SDLK_F6:
+//		    case SDLK_F7:
+//		    case SDLK_F8:
+//		    case SDLK_F9:
+//		    case SDLK_F10:
+//		    case SDLK_F11:
+//		    case SDLK_F12:
+//			if ( SDL_GetModState() & KMOD_ALT ) {
+//				if ( pressed ) {
+//					switch_vt(this, (keysym.sym-SDLK_F1)+1);
+//				}
+//				break;
+//			}
+			/* Fall through to normal processing */
+//		    default:
+			posted += SDL_PrivateKeyboard(pressed, &keysym);
+//			break;
+//		}
+	}
+}
+
+//DKS - reenabled this function that was commented out.. it is the same as the one I 
+// had pulled from fbcon/ when finishing USB keyboard stuff in 1.2.9
+void GP2X_InitOSKeymap(_THIS)
+{
+  int i;
+
+  /* Initialize the Linux key translation table */
+
+  /* First get the ascii keys and others not well handled */
+  for (i=0; i<SDL_TABLESIZE(keymap); ++i) {
+    switch(i) {
+      /* These aren't handled by the x86 kernel keymapping (?) */
+    case SCANCODE_PRINTSCREEN:
+      keymap[i] = SDLK_PRINT;
+      break;
+    case SCANCODE_BREAK:
+      keymap[i] = SDLK_BREAK;
+      break;
+    case SCANCODE_BREAK_ALTERNATIVE:
+      keymap[i] = SDLK_PAUSE;
+      break;
+    case SCANCODE_LEFTSHIFT:
+      keymap[i] = SDLK_LSHIFT;
+      break;
+    case SCANCODE_RIGHTSHIFT:
+      keymap[i] = SDLK_RSHIFT;
+      break;
+    case SCANCODE_LEFTCONTROL:
+      keymap[i] = SDLK_LCTRL;
+      break;
+    case SCANCODE_RIGHTCONTROL:
+      keymap[i] = SDLK_RCTRL;
+      break;
+    case SCANCODE_RIGHTWIN:
+      keymap[i] = SDLK_RSUPER;
+      break;
+    case SCANCODE_LEFTWIN:
+      keymap[i] = SDLK_LSUPER;
+      break;
+    case 127:
+      keymap[i] = SDLK_MENU;
+      break;
+      /* this should take care of all standard ascii keys */
+    default:
+      keymap[i] = KVAL(vga_keymap[0][i]);
+      break;
+    }
+  }
+  for (i=0; i<SDL_TABLESIZE(keymap); ++i) {
+    switch(keymap_temp[i]) {
+    case K_F1:  keymap[i] = SDLK_F1;  break;
+    case K_F2:  keymap[i] = SDLK_F2;  break;
+    case K_F3:  keymap[i] = SDLK_F3;  break;
+    case K_F4:  keymap[i] = SDLK_F4;  break;
+    case K_F5:  keymap[i] = SDLK_F5;  break;
+    case K_F6:  keymap[i] = SDLK_F6;  break;
+    case K_F7:  keymap[i] = SDLK_F7;  break;
+    case K_F8:  keymap[i] = SDLK_F8;  break;
+    case K_F9:  keymap[i] = SDLK_F9;  break;
+    case K_F10: keymap[i] = SDLK_F10; break;
+    case K_F11: keymap[i] = SDLK_F11; break;
+    case K_F12: keymap[i] = SDLK_F12; break;
+
+    case K_DOWN:  keymap[i] = SDLK_DOWN;  break;
+    case K_LEFT:  keymap[i] = SDLK_LEFT;  break;
+    case K_RIGHT: keymap[i] = SDLK_RIGHT; break;
+    case K_UP:    keymap[i] = SDLK_UP;    break;
+
+    case K_P0:     keymap[i] = SDLK_KP0; break;
+    case K_P1:     keymap[i] = SDLK_KP1; break;
+    case K_P2:     keymap[i] = SDLK_KP2; break;
+    case K_P3:     keymap[i] = SDLK_KP3; break;
+    case K_P4:     keymap[i] = SDLK_KP4; break;
+    case K_P5:     keymap[i] = SDLK_KP5; break;
+    case K_P6:     keymap[i] = SDLK_KP6; break;
+    case K_P7:     keymap[i] = SDLK_KP7; break;
+    case K_P8:     keymap[i] = SDLK_KP8; break;
+    case K_P9:     keymap[i] = SDLK_KP9; break;
+    case K_PPLUS:  keymap[i] = SDLK_KP_PLUS; break;
+    case K_PMINUS: keymap[i] = SDLK_KP_MINUS; break;
+    case K_PSTAR:  keymap[i] = SDLK_KP_MULTIPLY; break;
+    case K_PSLASH: keymap[i] = SDLK_KP_DIVIDE; break;
+    case K_PENTER: keymap[i] = SDLK_KP_ENTER; break;
+    case K_PDOT:   keymap[i] = SDLK_KP_PERIOD; break;
+
+    case K_SHIFT:  if ( keymap[i] != SDLK_RSHIFT )
+	keymap[i] = SDLK_LSHIFT;
+      break;
+    case K_SHIFTL: keymap[i] = SDLK_LSHIFT; break;
+    case K_SHIFTR: keymap[i] = SDLK_RSHIFT; break;
+    case K_CTRL:  if ( keymap[i] != SDLK_RCTRL )
+	keymap[i] = SDLK_LCTRL;
+      break;
+    case K_CTRLL:  keymap[i] = SDLK_LCTRL;  break;
+    case K_CTRLR:  keymap[i] = SDLK_RCTRL;  break;
+    case K_ALT:    keymap[i] = SDLK_LALT;   break;
+    case K_ALTGR:  keymap[i] = SDLK_RALT;   break;
+
+    case K_INSERT: keymap[i] = SDLK_INSERT;   break;
+    case K_REMOVE: keymap[i] = SDLK_DELETE;   break;
+    case K_PGUP:   keymap[i] = SDLK_PAGEUP;   break;
+    case K_PGDN:   keymap[i] = SDLK_PAGEDOWN; break;
+    case K_FIND:   keymap[i] = SDLK_HOME;     break;
+    case K_SELECT: keymap[i] = SDLK_END;      break;
+
+    case K_NUM:  keymap[i] = SDLK_NUMLOCK;   break;
+    case K_CAPS: keymap[i] = SDLK_CAPSLOCK;  break;
+
+    case K_F13:   keymap[i] = SDLK_PRINT;     break;
+    case K_HOLD:  keymap[i] = SDLK_SCROLLOCK; break;
+    case K_PAUSE: keymap[i] = SDLK_PAUSE;     break;
+
+    case 127: keymap[i] = SDLK_BACKSPACE; break;
+
+    default: break;
+    }
+  }
+}
+//DKS - commenting this out, it is oooold
+//void GP2X_InitOSKeymap(_THIS)
+//{
+//  int i;
+//
+//  /* Initialize the Linux key translation table */
+//
+//  /* First get the ascii keys and others not well handled */
+//  for (i=0; i<SDL_TABLESIZE(keymap); ++i)  // 128 
+//    {
+//      keymap[i] = 0; // all key map clear ==>  SDLK_UNKNOWN  
+//    }
+//
+//  keymap[0] =  SDLK_UNKNOWN	;
+//  keymap[3] =  SDLK_CTRL_C	;
+//  keymap[8] =  SDLK_BACKSPACE	;
+//  keymap[9] =  SDLK_TAB		;
+//  keymap[12] = SDLK_CLEAR		;
+//  keymap[13] = SDLK_RETURN	;
+//  keymap[19] = SDLK_PAUSE		;
+//  keymap[27] = SDLK_ESCAPE    ;
+//
+//
+//  for (i=32; i<=64; ++i)  // ' '  '@' 32
+//    {
+//      keymap[i] = i; // all key map clear ==>  SDLK_UNKNOWN  
+//    }
+//
+//  for (i=91; i<=122; ++i)  // '['  'z' 32
+//    {
+//      keymap[i] = i; // all key map clear ==>  SDLK_UNKNOWN  
+//    }
+//
+//  keymap[127] = SDLK_DELETE    ;
+//
+//
+//}
+//
+
+//DKS - ostensibly the same as what I used for 1.2.9's USB keyboard support, but I had 
+// left the unicode stuff uncommented so I will bring the 1.2.9 version back here as it's
+// already been tested.
+//static SDL_keysym *TranslateKey(int scancode, SDL_keysym *keysym)
+//{
+//  /* Set the keysym information */
+//  keysym->scancode = scancode;
+//  keysym->sym = keymap[scancode];
+//  keysym->mod = KMOD_NONE;
+//
+//  /* If UNICODE is on, get the UNICODE value for the key */
+//  keysym->unicode = 0;
+//#if 0 // 041206: ghcstop delete ?  keymap  serial console  
+//  if ( SDL_TranslateUNICODE ) {
+//    int map;
+//    SDLMod modstate;
+//
+//    modstate = SDL_GetModState();
+//    map = 0;
+//    if ( modstate & KMOD_SHIFT ) {
+//      map |= (1<<KG_SHIFT);
+//    }
+//    if ( modstate & KMOD_CTRL ) {
+//      map |= (1<<KG_CTRL);
+//    }
+//    if ( modstate & KMOD_ALT ) {
+//      map |= (1<<KG_ALT);
+//    }
+//    if ( modstate & KMOD_MODE ) {
+//      map |= (1<<KG_ALTGR);
+//    }
+//    if ( KTYP(vga_keymap[map][scancode]) == KT_LETTER ) {
+//      if ( modstate & KMOD_CAPS ) {
+//	map ^= (1<<KG_SHIFT);
+//      }
+//    }
+//    if ( KTYP(vga_keymap[map][scancode]) == KT_PAD ) {
+//      if ( modstate & KMOD_NUM ) {
+//	keysym->unicode=KVAL(vga_keymap[map][scancode]);
+//      }
+//    } else {
+//      keysym->unicode = KVAL(vga_keymap[map][scancode]);
+//    }
+//  }
+//#endif
+//  return(keysym);
+//}
+//DKS - pulled from virgin 1.2.9 
+static SDL_keysym *TranslateKey(int scancode, SDL_keysym *keysym)
+{
+	/* Set the keysym information */
+	keysym->scancode = scancode;
+	keysym->sym = keymap[scancode];
+	keysym->mod = KMOD_NONE;
+
+	/* If UNICODE is on, get the UNICODE value for the key */
+	keysym->unicode = 0;
+	if ( SDL_TranslateUNICODE ) {
+		int map;
+		SDLMod modstate;
+
+		modstate = SDL_GetModState();
+		map = 0;
+		if ( modstate & KMOD_SHIFT ) {
+			map |= (1<<KG_SHIFT);
+		}
+		if ( modstate & KMOD_CTRL ) {
+			map |= (1<<KG_CTRL);
+		}
+		if ( modstate & KMOD_ALT ) {
+			map |= (1<<KG_ALT);
+		}
+		if ( modstate & KMOD_MODE ) {
+			map |= (1<<KG_ALTGR);
+		}
+		if ( KTYP(vga_keymap[map][scancode]) == KT_LETTER ) {
+			if ( modstate & KMOD_CAPS ) {
+				map ^= (1<<KG_SHIFT);
+			}
+		}
+		if ( KTYP(vga_keymap[map][scancode]) == KT_PAD ) {
+			if ( modstate & KMOD_NUM ) {
+				keysym->unicode=KVAL(vga_keymap[map][scancode]);
+			}
+		} else {
+			keysym->unicode = KVAL(vga_keymap[map][scancode]);
+		}
+	}
+	return(keysym);
+}
+
+//DKS - updated to newer code pulled from 1.2.9
+//void GP2X_PumpEvents(_THIS)
+//{
+//  fd_set fdset;
+//  int max_fd;
+//  static struct timeval zero;
+//
+//  do {
+//    posted = 0;
+//
+//    FD_ZERO(&fdset);
+//    max_fd = 0;
+//    /*** TODO
+//    if (this->hidden->keyboard_fd >= 0) {
+//
+//      FD_SET(this->hidden->keyboard_fd, &fdset);
+//      if (max_fd < this->hidden->keyboard_fd) {
+//	max_fd = this->hidden->keyboard_fd;
+//      }
+//    }
+//    ***/
+//    if (this->hidden->mouse_fd >= 0) {
+//      FD_SET(this->hidden->mouse_fd, &fdset);
+//      if (max_fd < this->hidden->mouse_fd) {
+//	max_fd = this->hidden->mouse_fd;
+//      }
+//    }
+//    if (select(max_fd+1, &fdset, NULL, NULL, &zero) > 0) {
+//      /*** TODO
+//      if (this->hidden->keyboard_fd >= 0) {
+//	if (FD_ISSET(this->hidden->keyboard_fd, &fdset)) {
+//	  handle_keyboard(this);
+//	}
+//      }
+//      ***/
+//      if (this->hidden->mouse_fd >= 0) {
+//	if (FD_ISSET(this->hidden->mouse_fd, &fdset)) {
+//	  handle_mouse(this);
+//	}
+//      }
+//    }
+//  } while (posted);
+//}
+void GP2X_PumpEvents(_THIS)
+{
+  fd_set fdset;
+  int max_fd;
+  static struct timeval zero;
+
+  do {
+    posted = 0;
+
+    FD_ZERO(&fdset);
+    max_fd = 0;
+    if (this->hidden->keyboard_fd >= 0) {
+      FD_SET(this->hidden->keyboard_fd, &fdset);
+      if (max_fd < this->hidden->keyboard_fd) {
+	max_fd = this->hidden->keyboard_fd;
+      }
+    }
+    if (this->hidden->mouse_fd >= 0) {
+      FD_SET(this->hidden->mouse_fd, &fdset);
+      if (max_fd < this->hidden->mouse_fd) {
+	max_fd = this->hidden->mouse_fd;
+      }
+    }
+    if (select(max_fd+1, &fdset, NULL, NULL, &zero) > 0) {
+      if (this->hidden->keyboard_fd >= 0) {
+	if (FD_ISSET(this->hidden->keyboard_fd, &fdset)) {
+	  handle_keyboard(this);
+	}
+      }
+      if (this->hidden->mouse_fd >= 0) {
+	if (FD_ISSET(this->hidden->mouse_fd, &fdset)) {
+	  handle_mouse(this);
+	}
+      }
+    }
+  } while (posted);
+}
+
+
+/* end of SDL_gp2xevents.c ... */
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xevents_c.h SDL-1.2.11/src/video/gp2x/SDL_gp2xevents_c.h
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xevents_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xevents_c.h	2020-04-13 13:05:31.943199163 +0200
@@ -0,0 +1,43 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: SDL_gp2xevents_c.h,v 1.4 2004/01/04 16:49:24 slouken Exp $";
+#endif
+
+#include "SDL_gp2xvideo.h"
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern int GP2X_OpenMouse(_THIS);
+extern void GP2X_CloseMouse(_THIS);
+extern void GP2X_InitOSKeymap(_THIS);
+extern void GP2X_PumpEvents(_THIS);
+
+//DKS - new stuff for USB keyboard
+extern int GP2X_OpenKeyboard(_THIS);
+extern void GP2X_CloseKeyboard(_THIS);
+
+/* end of SDL_gp2xevents_c.h ... */
+
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xkeys.h SDL-1.2.11/src/video/gp2x/SDL_gp2xkeys.h
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xkeys.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xkeys.h	2020-04-13 13:05:31.943199163 +0200
@@ -0,0 +1,170 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: $";
+#endif
+
+#ifndef _SDL_gp2xkeys_h
+#define _SDL_gp2xkeys_h
+
+
+/* Scancodes for the Linux console
+   - Bits taken with thanks from SVGAlib 1.4.0
+*/
+
+#define SCANCODE_ESCAPE			1
+
+#define SCANCODE_1			2
+#define SCANCODE_2			3
+#define SCANCODE_3			4
+#define SCANCODE_4			5
+#define SCANCODE_5			6
+#define SCANCODE_6			7
+#define SCANCODE_7			8
+#define SCANCODE_8			9
+#define SCANCODE_9			10
+#define SCANCODE_0			11
+
+#define SCANCODE_MINUS			12
+#define SCANCODE_EQUAL			13
+
+#define SCANCODE_BACKSPACE		14
+#define SCANCODE_TAB			15
+
+#define SCANCODE_Q			16
+#define SCANCODE_W			17
+#define SCANCODE_E			18
+#define SCANCODE_R			19
+#define SCANCODE_T			20
+#define SCANCODE_Y			21
+#define SCANCODE_U			22
+#define SCANCODE_I			23
+#define SCANCODE_O			24
+#define SCANCODE_P			25
+#define SCANCODE_BRACKET_LEFT		26
+#define SCANCODE_BRACKET_RIGHT		27
+
+#define SCANCODE_ENTER			28
+
+#define SCANCODE_LEFTCONTROL		29
+
+#define SCANCODE_A			30
+#define SCANCODE_S			31
+#define SCANCODE_D			32
+#define SCANCODE_F			33
+#define SCANCODE_G			34
+#define SCANCODE_H			35
+#define SCANCODE_J			36
+#define SCANCODE_K			37
+#define SCANCODE_L			38
+#define SCANCODE_SEMICOLON		39
+#define SCANCODE_APOSTROPHE		40
+#define SCANCODE_GRAVE			41
+
+#define SCANCODE_LEFTSHIFT		42
+#define SCANCODE_BACKSLASH		43
+
+#define SCANCODE_Z			44
+#define SCANCODE_X			45
+#define SCANCODE_C			46
+#define SCANCODE_V			47
+#define SCANCODE_B			48
+#define SCANCODE_N			49
+#define SCANCODE_M			50
+#define SCANCODE_COMMA			51
+#define SCANCODE_PERIOD			52
+#define SCANCODE_SLASH			53
+
+#define SCANCODE_RIGHTSHIFT		54
+#define SCANCODE_KEYPADMULTIPLY		55
+
+#define SCANCODE_LEFTALT		56
+#define SCANCODE_SPACE			57
+#define SCANCODE_CAPSLOCK		58
+
+#define SCANCODE_F1			59
+#define SCANCODE_F2			60
+#define SCANCODE_F3			61
+#define SCANCODE_F4			62
+#define SCANCODE_F5			63
+#define SCANCODE_F6			64
+#define SCANCODE_F7			65
+#define SCANCODE_F8			66
+#define SCANCODE_F9			67
+#define SCANCODE_F10			68
+
+#define SCANCODE_NUMLOCK		69
+#define SCANCODE_SCROLLLOCK		70
+
+#define SCANCODE_KEYPAD7		71
+#define SCANCODE_CURSORUPLEFT		71
+#define SCANCODE_KEYPAD8		72
+#define SCANCODE_CURSORUP		72
+#define SCANCODE_KEYPAD9		73
+#define SCANCODE_CURSORUPRIGHT		73
+#define SCANCODE_KEYPADMINUS		74
+#define SCANCODE_KEYPAD4		75
+#define SCANCODE_CURSORLEFT		75
+#define SCANCODE_KEYPAD5		76
+#define SCANCODE_KEYPAD6		77
+#define SCANCODE_CURSORRIGHT		77
+#define SCANCODE_KEYPADPLUS		78
+#define SCANCODE_KEYPAD1		79
+#define SCANCODE_CURSORDOWNLEFT		79
+#define SCANCODE_KEYPAD2		80
+#define SCANCODE_CURSORDOWN		80
+#define SCANCODE_KEYPAD3		81
+#define SCANCODE_CURSORDOWNRIGHT	81
+#define SCANCODE_KEYPAD0		82
+#define SCANCODE_KEYPADPERIOD		83
+
+#define SCANCODE_LESS			86
+
+#define SCANCODE_F11			87
+#define SCANCODE_F12			88
+
+#define SCANCODE_KEYPADENTER		96
+#define SCANCODE_RIGHTCONTROL		97
+#define SCANCODE_CONTROL		97
+#define SCANCODE_KEYPADDIVIDE		98
+#define SCANCODE_PRINTSCREEN		99
+#define SCANCODE_RIGHTALT		100
+#define SCANCODE_BREAK			101	/* Beware: is 119     */
+#define SCANCODE_BREAK_ALTERNATIVE	119	/* on some keyboards! */
+
+#define SCANCODE_HOME			102
+#define SCANCODE_CURSORBLOCKUP		103	/* Cursor key block */
+#define SCANCODE_PAGEUP			104
+#define SCANCODE_CURSORBLOCKLEFT	105	/* Cursor key block */
+#define SCANCODE_CURSORBLOCKRIGHT	106	/* Cursor key block */
+#define SCANCODE_END			107
+#define SCANCODE_CURSORBLOCKDOWN	108	/* Cursor key block */
+#define SCANCODE_PAGEDOWN		109
+#define SCANCODE_INSERT			110
+#define SCANCODE_REMOVE			111
+
+#define SCANCODE_RIGHTWIN		126
+#define SCANCODE_LEFTWIN		125
+
+#endif // _SDL_gp2xkeys_h
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xmouse.c SDL-1.2.11/src/video/gp2x/SDL_gp2xmouse.c
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xmouse.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xmouse.c	2020-04-13 13:05:31.944199191 +0200
@@ -0,0 +1,42 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: SDL_gp2xmouse.c,v 1.4 2004/01/04 16:49:24 slouken Exp $";
+#endif
+
+#include <stdio.h>
+
+#include "SDL_error.h"
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_gp2xmouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+  video_bucket *bucket;
+  int dimension;
+  unsigned short fgr, fb, bgr, bb, falpha, balpha;
+};
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xmouse_c.h SDL-1.2.11/src/video/gp2x/SDL_gp2xmouse_c.h
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xmouse_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xmouse_c.h	2020-04-13 13:05:31.943199163 +0200
@@ -0,0 +1,30 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: SDL_gp2xmouse_c.h,v 1.4 2004/01/04 16:49:24 slouken Exp $";
+#endif
+
+#include "SDL_gp2xvideo.h"
+
+/* Functions to be exported */
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xvideo.c SDL-1.2.11/src/video/gp2x/SDL_gp2xvideo.c
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xvideo.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xvideo.c	2020-04-13 13:05:31.942199134 +0200
@@ -0,0 +1,1640 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: $";
+#endif
+
+/*
+ * GP2X SDL video driver implementation,
+ *  Base, dummy.
+ *  Memory routines based on fbcon
+ */
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+#include "SDL.h"
+#include "SDL_error.h"
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_gp2xvideo.h"
+#include "SDL_gp2xevents_c.h"
+#include "SDL_gp2xmouse_c.h"
+#include "SDL_gp2xyuv_c.h"
+#include "mmsp2_regs.h"
+
+#define GP2XVID_DRIVER_NAME "GP2X"
+
+
+// Initialization/Query functions
+static int GP2X_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **GP2X_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+static SDL_Surface *GP2X_SetVideoMode(_THIS, SDL_Surface *current,
+				      int width, int height,
+				      int bpp, Uint32 flags);
+static int GP2X_SetColors(_THIS, int firstcolor, int ncolors,
+			  SDL_Color *colors);
+static void GP2X_VideoQuit(_THIS);
+
+// Hardware surface functions
+static void GP2X_SurfaceFree(_THIS, video_bucket *bucket);
+static video_bucket *GP2X_SurfaceAllocate(_THIS, int size);
+
+static int GP2X_InitHWSurfaces(_THIS /*, SDL_Surface *screen,
+				       char *base, int size */ );
+static void GP2X_FreeHWSurfaces(_THIS);
+static int GP2X_AllocHWSurface(_THIS, SDL_Surface *surface);
+static int GP2X_LockHWSurface(_THIS, SDL_Surface *surface);
+static void GP2X_UnlockHWSurface(_THIS, SDL_Surface *surface);
+static void GP2X_FreeHWSurface(_THIS, SDL_Surface *surface);
+static void GP2X_DummyBlit(_THIS);
+static int GP2X_FlipHWSurface(_THIS, SDL_Surface *surface);
+// etc.
+static void GP2X_UpdateRects(_THIS, int numrects, SDL_Rect *rects);
+static int GP2X_CheckHWBlit(_THIS, SDL_Surface *src, SDL_Surface *dst);
+static int GP2X_FillHWRect(_THIS, SDL_Surface *surface,
+			   SDL_Rect *area, Uint32 colour);
+static int GP2X_HWAccelBlit(SDL_Surface *src, SDL_Rect *src_rect,
+			    SDL_Surface *dst, SDL_Rect *dst_rect);
+// cursor
+static WMcursor *GP2X_CreateWMCursor(SDL_VideoDevice *video,
+				     Uint8 *data, Uint8 *mask,
+				     int w, int h,
+				     int hot_x, int hot_y);
+static void GP2X_FreeWMCursor(_THIS, WMcursor *cursor);
+static int GP2X_ShowWMCursor(_THIS, WMcursor *cursor);
+static void GP2X_WarpWMCursor(_THIS, Uint16 x, Uint16 y);
+static void GP2X_MoveWMCursor(_THIS, int x, int y);
+
+////////
+// GP2X driver bootstrap functions
+////////
+
+////
+// Are we available?
+static int GP2X_Available(void)
+{
+  // Of course we are.
+  return 1;
+}
+
+////
+// Cleanup routine
+static void GP2X_DeleteDevice(SDL_VideoDevice *device)
+{
+  SDL_PrivateVideoData *data = device->hidden;
+  int i;
+#ifdef GP2X_DEBUG
+  fputs("SDL_GP2X: DeleteDevice\n", stderr);
+#endif
+
+  if (data->fio)
+    munmap(data->fio, 0x100);
+  if (data->io) {
+    // Clear register bits we clobbered if they weren't on
+    if (data->fastioclk == 0)
+      data->io[SYSCLKENREG] &= ~(FASTIOCLK);
+    if (data->grpclk == 0)
+      data->io[VCLKENREG] &= ~(GRPCLK);
+    // reset display hardware
+    data->io[MLC_STL_CNTL]   = data->stl_cntl;
+    data->io[MLC_STL_MIXMUX] = data->stl_mixmux;
+    data->io[MLC_STL_ALPHAL] = data->stl_alphal;
+    data->io[MLC_STL_ALPHAH] = data->stl_alphah;
+    data->io[MLC_STL_HSC]    = data->stl_hsc;
+    data->io[MLC_STL_VSCL]   = data->stl_vscl;
+    data->io[MLC_STL_VSCH]   = data->stl_vsch;
+    data->io[MLC_STL_HW]     = data->stl_hw;
+    data->io[MLC_STL_OADRL]  = data->stl_oadrl;
+    data->io[MLC_STL_OADRH]  = data->stl_oadrh;
+    data->io[MLC_STL_EADRL]  = data->stl_eadrl;
+    data->io[MLC_STL_EADRH]  = data->stl_eadrh;
+    for (i = 0; i < 16; i++)
+      data->io[MLC_STL1_STX + i] = data->stl_regions[i];
+    data->io[MLC_OVLAY_CNTR] = data->mlc_ovlay_cntr;
+    munmap(data->io, 0x10000);
+  }
+  if (data->vmem)
+    munmap(data->vmem, GP2X_VIDEO_MEM_SIZE);
+
+  if (data->fbcon_fd)
+    close(data->fbcon_fd);
+
+  if (data->memory_fd)
+    close(data->memory_fd);
+  free(device->hidden);
+  free(device);
+}
+
+////
+// Initalize driver
+static SDL_VideoDevice *GP2X_CreateDevice(int devindex)
+{
+  SDL_VideoDevice *device;
+#ifdef GP2X_DEBUG
+  fputs("SDL_GP2X: CreateDevice\n", stderr);
+#endif
+
+  /* Initialize all variables that we clean on shutdown */
+  device = (SDL_VideoDevice *)malloc(sizeof(SDL_VideoDevice));
+  if (device) {
+    memset(device, 0, (sizeof *device));
+    device->hidden = (struct SDL_PrivateVideoData *)
+      malloc((sizeof *device->hidden));
+  }
+  if ((device == NULL) || (device->hidden == NULL)) {
+    SDL_OutOfMemory();
+    if (device) {
+      free(device);
+    }
+    return 0;
+  }
+  memset(device->hidden, 0, (sizeof *device->hidden));
+
+  device->hidden->mouse_fd = -1;
+  device->hidden->keyboard_fd = -1;
+
+  // senquack - new user-configurable option, see SDL_gp2xvideo.h for description
+  device->hidden->mouse_button_events_enabled = 1;		/* default is enabled */
+  // senquack - new user-configurable option, see SDL_gp2xvideo.h for description
+  device->hidden->mouse_motion_events_enabled = 1;		/* default is enabled */
+
+  // Set the function pointers
+  device->VideoInit = GP2X_VideoInit;
+  device->ListModes = GP2X_ListModes;
+  device->SetVideoMode = GP2X_SetVideoMode;
+  device->CreateYUVOverlay = GP2X_CreateYUVOverlay;
+  device->SetColors = GP2X_SetColors;
+  device->UpdateRects = GP2X_UpdateRects;
+  device->VideoQuit = GP2X_VideoQuit;
+  device->AllocHWSurface = GP2X_AllocHWSurface;
+  device->CheckHWBlit = GP2X_CheckHWBlit;
+  device->FillHWRect = GP2X_FillHWRect;
+  device->SetHWColorKey = NULL;
+  device->SetHWAlpha = NULL;
+  device->LockHWSurface = GP2X_LockHWSurface;
+  device->UnlockHWSurface = GP2X_UnlockHWSurface;
+  device->FlipHWSurface = GP2X_FlipHWSurface;
+  device->FreeHWSurface = GP2X_FreeHWSurface;
+  device->SetCaption = NULL;
+  device->SetIcon = NULL;
+  device->IconifyWindow = NULL;
+  device->GrabInput = NULL;
+  device->GetWMInfo = NULL;
+  device->InitOSKeymap = GP2X_InitOSKeymap;
+  device->PumpEvents = GP2X_PumpEvents;
+  device->CreateWMCursor = GP2X_CreateWMCursor;
+  device->FreeWMCursor = GP2X_FreeWMCursor;
+  device->ShowWMCursor = GP2X_ShowWMCursor;
+  device->WarpWMCursor = GP2X_WarpWMCursor;
+  device->MoveWMCursor = GP2X_MoveWMCursor;
+  device->free = GP2X_DeleteDevice;
+
+  return device;
+}
+
+////
+// Link info to SDL_video
+VideoBootStrap GP2X_bootstrap = {
+  GP2XVID_DRIVER_NAME, "SDL GP2X video driver",
+  GP2X_Available, GP2X_CreateDevice
+};
+
+////
+// Set up hardware
+static int GP2X_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+  int i;
+#ifdef GP2X_DEBUG
+  fputs("SDL_GP2X: VideoInit\n", stderr);
+#endif
+
+#ifndef DISABLE_THREADS
+  // Create hardware surface lock mutex
+  data->hw_lock = SDL_CreateMutex();
+  if (data->hw_lock == NULL) {
+    SDL_SetError("Unable to create lock mutex");
+    GP2X_VideoQuit(this);
+    return -1;
+  }
+#endif
+
+  data->memory_fd = open("/dev/mem", O_RDWR, 0);
+  if (data->memory_fd < 0) {
+    SDL_SetError("Unable to open /dev/mem");
+    return -1;
+  }
+  data->fbcon_fd = open("/dev/fb0", O_RDWR, 0);
+  if (data->fbcon_fd < 0) {
+    SDL_SetError("Unable to open /dev/fb0");
+    return -1;
+  }
+  data->vmem = mmap(NULL, GP2X_VIDEO_MEM_SIZE, PROT_READ|PROT_WRITE,
+		    MAP_SHARED, data->memory_fd, GP2X_UPPER_MEM_START);
+  if (data->vmem == (char *)-1) {
+    SDL_SetError("Unable to get video memory");
+    data->vmem = NULL;
+    GP2X_VideoQuit(this);
+    return -1;
+  }
+  data->io = mmap(NULL, 0x10000, PROT_READ|PROT_WRITE,
+		  MAP_SHARED, data->memory_fd, 0xc0000000);
+  if (data->io == (unsigned short *)-1) {
+    SDL_SetError("Unable to get hardware registers");
+    data->io = NULL;
+    GP2X_VideoQuit(this);
+    return -1;
+  }
+  data->fio = mmap(NULL, 0x100, PROT_READ|PROT_WRITE,
+		  MAP_SHARED, data->memory_fd, 0xe0020000);
+  if (data->fio == (unsigned int *)-1) {
+    SDL_SetError("Unable to get blitter registers");
+    data->fio = NULL;
+    GP2X_VideoQuit(this);
+    return -1;
+  }
+
+  // Determine the screen depth (gp2x defaults to 16-bit depth)
+  // we change this during the SDL_SetVideoMode implementation...
+  vformat->BitsPerPixel = 16;
+  vformat->BytesPerPixel = 2;
+  vformat->Rmask = 0x1f00;
+  vformat->Gmask = 0x07e0;
+  vformat->Bmask = 0x001f;
+  vformat->Amask = 0;
+
+  this->info.wm_available = 0;
+  this->info.hw_available = 1;
+  this->info.video_mem = GP2X_VIDEO_MEM_SIZE / 1024;
+  //  memset(data->vmem, GP2X_VIDEO_MEM_SIZE, 0);
+  // Save hw register data that we clobber
+  data->fastioclk = data->io[SYSCLKENREG] & FASTIOCLK;
+  data->grpclk = data->io[VCLKENREG] & GRPCLK;
+  // Need FastIO for blitter
+  data->io[SYSCLKENREG] |= FASTIOCLK;
+  // and enable graphics clock
+  data->io[VCLKENREG] |= GRPCLK;
+
+  // Save display registers so we can restore screen to original state
+  data->stl_cntl =   data->io[MLC_STL_CNTL];
+  data->stl_mixmux = data->io[MLC_STL_MIXMUX];
+  data->stl_alphal = data->io[MLC_STL_ALPHAL];
+  data->stl_alphah = data->io[MLC_STL_ALPHAH];
+  data->stl_hsc =    data->io[MLC_STL_HSC];
+  data->stl_vscl =   data->io[MLC_STL_VSCL];
+  // HW bug - MLC_STL_VSCH returns VSCL instead
+  data->stl_vsch =   0;//data->io[MLC_STL_VSCH];
+  data->stl_hw =     data->io[MLC_STL_HW];
+  data->stl_oadrl =  data->io[MLC_STL_OADRL];
+  data->stl_oadrh =  data->io[MLC_STL_OADRH];
+  data->stl_eadrl =  data->io[MLC_STL_EADRL];
+  data->stl_eadrh =  data->io[MLC_STL_EADRH];
+  // save the 4 region areas
+  for (i = 0; i < 16; i++)
+    data->stl_regions[i] = data->io[MLC_STL1_STX + i];
+  data->mlc_ovlay_cntr = data->io[MLC_OVLAY_CNTR];
+
+  // Save vsync polarity (since GPH change it in different firmwares)
+  data->vsync_polarity = data->io[DPC_V_SYNC] & DPC_VSFLDPOL;
+  // Check what video mode we're in (LCD, NTSC or PAL)
+  data->phys_width = data->io[DPC_X_MAX] + 1;
+  data->phys_height = data->io[DPC_Y_MAX] + 1;
+  data->phys_ilace = (data->io[DPC_CNTL] & DPC_INTERLACE) ? 1 : 0;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: Physical screen = %dx%d (ilace = %d, pol = %d)\n",
+	  data->phys_width, data->phys_height, data->phys_ilace, data->vsync_polarity);
+#endif
+  for (i = 0; i < SDL_NUMMODES; i++) {
+    data->SDL_modelist[i] = malloc(sizeof(SDL_Rect));
+    data->SDL_modelist[i]->x = data->SDL_modelist[i]->y = 0;
+  }
+  data->SDL_modelist[0]->w =  320; data->SDL_modelist[0]->h = 200; // low-res
+  data->SDL_modelist[1]->w =  320; data->SDL_modelist[1]->h = 240; // lo-res
+  data->SDL_modelist[2]->w =  640; data->SDL_modelist[2]->h = 400; // vga-low
+  data->SDL_modelist[3]->w =  640; data->SDL_modelist[3]->h = 480; // vga
+  data->SDL_modelist[4]->w =  720; data->SDL_modelist[4]->h = 480; // TV NTSC
+  data->SDL_modelist[5]->w =  720; data->SDL_modelist[5]->h = 576; // TV PAL
+  data->SDL_modelist[6]->w =  800; data->SDL_modelist[6]->h = 600; // vga-med
+  data->SDL_modelist[7]->w = 1024; data->SDL_modelist[7]->h = 768; // vga-high
+  data->SDL_modelist[8] = NULL;
+
+  this->info.blit_fill = 1;
+  this->FillHWRect = GP2X_FillHWRect;
+  this->info.blit_hw = 1;
+  this->info.blit_hw_CC = 1;
+
+  GP2X_InitHWSurfaces(this);
+  // Enable mouse and keyboard support
+  GP2X_OpenKeyboard(this);
+  GP2X_OpenMouse(this);
+  return 0;
+}
+
+////
+// Return list of possible screen sizes for given mode
+static SDL_Rect **GP2X_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: ListModes\n");
+#endif
+  // Only 8 & 16 bit modes. 4 & 24 are available, but tough.
+  if ((format->BitsPerPixel != 8) && (format->BitsPerPixel != 16))
+    return NULL;
+
+  if (flags & SDL_FULLSCREEN)
+    return this->hidden->SDL_modelist;
+  else
+    return (SDL_Rect **) -1;
+}
+
+////
+// Set hw videomode
+static SDL_Surface *GP2X_SetVideoMode(_THIS, SDL_Surface *current,
+				      int width, int height,
+				      int bpp, Uint32 flags)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+  video_bucket *screen_bucket;
+  char *pixelbuffer;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: Setting video mode %dx%d %d bpp, flags=%X\n",
+	  width, height, bpp, flags);
+#endif
+
+  // Set up the new mode framebuffer, making sanity adjustments
+  // 64 <= width <= 1024, multiples of 8 only
+  width = (width + 7) & 0x7f8;
+  if (width < 64) width = 64;
+  if (width > 1024) width = 1024;
+
+  // 64 <= height <= 768
+  if (height < 64) height = 64;
+  if (height > 768) height = 768;
+
+  // 8 or 16 bpp. HW can handle 24, but limited support so not implemented
+  bpp = (bpp <= 8) ? 8 : 16;
+
+  // Allocate the new pixel format for the screen
+  if (!SDL_ReallocFormat(current, bpp, 0, 0, 0, 0)) {
+    SDL_SetError("Couldn't allocate new pixel format for requested mode");
+    return NULL;
+  }
+
+  // Screen is always a HWSURFACE and FULLSCREEN
+  current->flags = (flags & SDL_DOUBLEBUF) | SDL_FULLSCREEN |
+    SDL_HWSURFACE | SDL_NOFRAME;
+  if (bpp == 8) current->flags |= SDL_HWPALETTE;
+  data->w = current->w = width;
+  data->h = current->h = height;
+  data->pitch = data->phys_pitch = current->pitch = width * (bpp / 8);
+  if (data->phys_ilace && (width == 720))
+    data->phys_pitch *= 2;
+  this->screen = current;
+  SDL_CursorQuit();
+  GP2X_FreeHWSurfaces(this);
+  GP2X_InitHWSurfaces(this);
+  // sep screen from allocator: removed 1 line, added 2 lines
+  //current->pixels = data->vmem + GP2X_SCREEN_OFFSET;
+  screen_bucket = GP2X_SurfaceAllocate(this, height * data->pitch * ((flags & SDL_DOUBLEBUF) ? 2:1));
+  if (!screen_bucket)
+    return NULL;
+  current->pixels = screen_bucket->base;
+
+  data->x_offset = data->y_offset = 0;
+  data->ptr_offset = 0;
+  // gp2x holds x-scale as fixed-point, 1024 == 1:1
+  data->scale_x = (1024 * width) / data->phys_width;
+  // and y-scale is scale * pitch
+  data->scale_y = (height * data->pitch) / data->phys_height;
+  // xscale and yscale are set so that virtual_x * xscale = phys_x (16.16)
+  data->xscale = (data->phys_width << 16) / width;
+  data->yscale = (data->phys_height << 16) / height;
+  // invxscale and invyscale are inverse for touchscreen use (16.16)
+  data->invxscale = (width << 16) / data->phys_width;
+  data->invyscale = (height << 16) / data->phys_height;
+
+  data->buffer_showing = 0;
+  data->buffer_addr[0] = current->pixels;
+  data->surface_mem = data->vmem; // + (height * data->pitch);
+  data->memory_max = GP2X_VIDEO_MEM_SIZE - height * data->pitch;
+  if (flags & SDL_DOUBLEBUF) {
+    data->buffer_addr[1] = current->pixels += height * data->pitch;
+    //    data->surface_mem += height * data->pitch;
+    data->memory_max -= height * data->pitch;
+  }
+  // sep screen from allocator - added 1 line, removed 1 line
+  current->hwdata = (struct private_hwdata *)&data->video_mem;
+  //  GP2X_InitHWSurfaces(this, current, data->surface_mem, data->memory_max);
+
+  // Load the registers
+  data->io[MLC_STL_HSC] = data->scale_x;
+  data->io[MLC_STL_VSCL] = data->scale_y & 0xffff;
+  data->io[MLC_STL_VSCH] = data->scale_y >> 16;
+  data->io[MLC_STL_HW] = data->phys_pitch;
+  data->io[MLC_STL_CNTL] = (bpp==8 ? MLC_STL_BPP_8 : MLC_STL_BPP_16) |
+    MLC_STL1ACT;
+  data->io[MLC_STL_MIXMUX] = 0;
+  data->io[MLC_STL_ALPHAL] = 255;
+  data->io[MLC_STL_ALPHAH] = 255;
+  data->io[MLC_OVLAY_CNTR] |= DISP_STL1EN;
+
+  pixelbuffer = current->pixels;
+  if (data->phys_ilace) {
+    data->io[MLC_STL_OADRL] = GP2X_PhysL(this, pixelbuffer);
+    data->io[MLC_STL_OADRH] = GP2X_PhysH(this, pixelbuffer);
+    if (data->w == 720) pixelbuffer += data->pitch;
+  }
+  data->io[MLC_STL_EADRL] = GP2X_PhysL(this, pixelbuffer);
+  data->io[MLC_STL_EADRH] = GP2X_PhysH(this, pixelbuffer);
+
+  return current;
+}
+
+////
+// Initialize HW surface list
+//static int GP2X_InitHWSurfaces(_THIS, SDL_Surface *screen, char *base, int size)
+static int GP2X_InitHWSurfaces(_THIS)
+{
+  video_bucket *bucket, *first_bucket, *second_bucket, *third_bucket;
+  int cursor_state;
+  char *base = this->hidden->vmem;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: InitHWSurfaces\n");
+#endif
+
+  first_bucket = (video_bucket *)malloc(sizeof(*bucket));
+  second_bucket = (video_bucket *)malloc(sizeof(*bucket));
+  if ((first_bucket == NULL) || (second_bucket == NULL)) {
+    SDL_OutOfMemory();
+    return -1;
+  }
+
+  // ***HACK*** whether gfx memory has 16MB scratch available
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: InitHWSurfaces scratch = %d\n", this->hidden->allow_scratch_memory);
+#endif
+  if (this->hidden->allow_scratch_memory) {
+    third_bucket = (video_bucket *)malloc(sizeof(*bucket));
+    if (third_bucket == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+    }
+    first_bucket->next = second_bucket;
+    first_bucket->prev = &this->hidden->video_mem;
+    first_bucket->used = 0;
+    first_bucket->dirty = 0;
+    first_bucket->base = base;
+    first_bucket->size = 16*1024*1024;
+
+    second_bucket->next = third_bucket;
+    second_bucket->prev = first_bucket;
+    second_bucket->used = 2;
+    second_bucket->dirty = 0;
+    second_bucket->base = base + 16*1024*1024;
+    second_bucket->size = 1024*1024;
+
+    third_bucket->next = NULL;
+    third_bucket->prev = second_bucket;
+    third_bucket->used = 0;
+    third_bucket->dirty = 0;
+    third_bucket->base = base + 17*1024*1024;
+    third_bucket->size = 5*1024*1024;
+  } else {
+    first_bucket->next = second_bucket;
+    first_bucket->prev = &this->hidden->video_mem;
+    first_bucket->used = 2;
+    first_bucket->dirty = 0;
+    first_bucket->base = base;
+    first_bucket->size = 17*1024*1024;
+
+    second_bucket->next = NULL;
+    second_bucket->prev = first_bucket;
+    second_bucket->used = 0;
+    second_bucket->dirty = 0;
+    second_bucket->base = base + 17*1024*1024;
+    second_bucket->size = 5*1024*1024;
+  }
+
+  this->hidden->video_mem.next = first_bucket;
+  this->hidden->video_mem.prev = NULL;
+  this->hidden->video_mem.used = 1;
+  this->hidden->video_mem.dirty = 0;
+  this->hidden->video_mem.base = base; // screen->pixels;
+  //  this->hidden->video_mem.size = (unsigned int)((long)base - (long)screen->pixels);
+  // set these three variables to amount of memory free
+  this->hidden->video_mem.size =
+    this->hidden->memory_left =
+    this->hidden->memory_max =
+    (this->hidden->allow_scratch_memory ? 21:5) * 1024*1024;
+
+  ////
+  //  screen->hwdata = (struct private_hwdata *)&this->hidden->video_mem;
+
+  SDL_CursorInit(1);
+
+  return 0;
+}
+
+////
+// Insert invalid addresses into surface list
+static int GP2X_insert_invalid_memory(_THIS, char *block_start, int block_size)
+{
+  video_bucket *bucket = &this->hidden->video_mem;
+  char *block_end = block_start + block_size;
+
+  // Find bucket which encloses invalid area
+
+  while (((bucket = bucket->next) != NULL) &&
+	 (bucket->base + bucket->size <= block_start)) {
+    if (bucket->base > block_start) {
+      bucket = NULL;
+      break;
+    }
+  }
+  if (bucket == NULL) {
+#ifdef GP2X_DEBUG
+    fputs("GP2X_insert_invalid_memory: block not in bucket list\n", stderr);
+#endif
+    return -1;
+  }
+}
+
+////
+// Free all surfaces
+static void GP2X_FreeHWSurfaces(_THIS)
+{
+  video_bucket *curr, *next;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: FreeHWSurfaces\n");
+#endif
+
+  next = this->hidden->video_mem.next;
+  while (next) {
+#ifdef GP2X_DEBUG
+    fprintf(stderr, "SDL_GP2X: Freeing bucket %p (size %d)\n", next, next->size);
+#endif
+    curr = next;
+    next = curr->next;
+    free(curr);
+  }
+  this->hidden->video_mem.next = NULL;
+}
+
+//// SURFACE MEMORY MANAGER
+// Allocate memory from free pool
+static video_bucket *GP2X_SurfaceAllocate(_THIS, int size)
+{
+  int left_over;
+  video_bucket *bucket;
+  SDL_PrivateVideoData *data = this->hidden;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: SurfaceManager allocating %d bytes\n", size);
+#endif
+
+  if (size > data->memory_left) {
+    SDL_SetError("Not enough video memory");
+    return NULL;
+  }
+
+  for (bucket = &data->video_mem; bucket; bucket = bucket->next)
+    if (!bucket->used && (size <= bucket->size))
+      break;
+  if (!bucket) {
+    SDL_SetError("Video memory too fragmented");
+    return NULL;
+  }
+
+  left_over = bucket->size - size;
+  if (left_over) {
+    video_bucket *new_bucket;
+    new_bucket = (video_bucket *)malloc(sizeof(*new_bucket));
+    if (!new_bucket) {
+      SDL_OutOfMemory();
+      return NULL;
+    }
+#ifdef GP2X_DEBUG
+    fprintf(stderr, "SDL_GP2X: SurfaceManager adding new free bucket of %d bytes @ %p\n", left_over, new_bucket);
+#endif
+    new_bucket->prev = bucket;
+    new_bucket->used = 0;
+    new_bucket->dirty = 0;
+    new_bucket->size = left_over;
+    new_bucket->base = bucket->base + size;
+    new_bucket->next = bucket->next;
+    if (bucket->next)
+      bucket->next->prev = new_bucket;
+    bucket->next = new_bucket;
+  }
+  bucket->used = 1;
+  bucket->size = size;
+  bucket->dirty = 0;
+  data->memory_left -= size;
+
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: SurfaceManager allocated %d bytes at %p\n", size, bucket->base);
+#endif
+  return bucket;
+}
+
+////
+// Return memory to free pool
+static void GP2X_SurfaceFree(_THIS, video_bucket *bucket)
+{
+  video_bucket *wanted;
+  SDL_PrivateVideoData *data = this->hidden;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: SurfaceManager freeing %d bytes @ %p from bucket %p\n", bucket->size, bucket->base, bucket);
+#endif
+
+  if (bucket->used == 1) {
+    data->memory_left += bucket->size;
+    bucket->used = 0;
+
+    if (bucket->next && !bucket->next->used) {
+#ifdef GP2X_DEBUG
+      fprintf(stderr, "SDL_GP2X: merging with next bucket (%p) making %d bytes\n",
+	      bucket->next, bucket->size + bucket->next->size);
+#endif
+      wanted = bucket->next;
+      bucket->size += bucket->next->size;
+      bucket->next = bucket->next->next;
+      if (bucket->next)
+	bucket->next->prev = bucket;
+      free(wanted);
+    }
+
+    if (bucket->prev && !bucket->prev->used) {
+#ifdef GP2X_DEBUG
+      fprintf(stderr, "SDL_GP2X: merging with previous bucket (%p) making %d bytes\n",
+	      bucket->prev, bucket->size + bucket->prev->size);
+#endif
+      wanted = bucket->prev;
+      wanted->size += bucket->size;
+      wanted->next = bucket->next;
+      if (bucket->next)
+	bucket->next->prev = wanted;
+      free(bucket);
+    }
+  }
+}
+
+////
+// Allocate a surface from video memory
+static int GP2X_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+  int w, h, pitch, size;
+  video_bucket *gfx_memory;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: AllocHWSurface %p\n", surface);
+#endif
+  h = surface->h;
+  w = surface->w;
+  pitch = ((w * surface->format->BytesPerPixel) + 3) & ~3; // 32-bit align
+  size = h * pitch;
+  gfx_memory = GP2X_SurfaceAllocate(this, size);
+  if (gfx_memory == NULL)
+    return -1;
+
+  surface->hwdata = (struct private_hwdata *)gfx_memory;
+  surface->pixels = gfx_memory->base;
+  surface->flags |= SDL_HWSURFACE;
+#ifdef GP2X_DEBUG
+  fputs("SDL_GP2X: Allocated\n", stderr);
+#endif
+  return 0;
+}
+
+////
+// Free a surface back to video memry
+static void GP2X_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+  video_bucket *bucket;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: FreeHWSurface %p\n", surface);
+#endif
+  /*
+  for (bucket = &data->video_mem; bucket; bucket = bucket->next)
+    if (bucket == (video_bucket *)surface->hwdata)
+      break;
+  */
+  bucket = (video_bucket *)surface->hwdata;
+  GP2X_SurfaceFree(this, bucket);
+  surface->pixels = NULL;
+  surface->hwdata = NULL;
+}
+
+////
+// Mark surface as unavailable for HW acceleration
+static int GP2X_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+  if (surface == this->screen)
+    SDL_mutexP(this->hidden->hw_lock);
+
+  if (GP2X_IsSurfaceBusy(surface)) {
+    GP2X_DummyBlit(this);
+    GP2X_WaitBusySurfaces(this);
+  }
+  return 0;
+}
+
+////
+// Hardware can use the surface now
+static void GP2X_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+  if (surface == this->screen)
+    SDL_mutexV(this->hidden->hw_lock);
+}
+
+////
+// Dummy blit to flush blitter cache
+static void GP2X_DummyBlit(_THIS)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+#ifdef GP2X_DEBUG
+  //  fputs("SDL_GP2X: DummyBlit\n", stderr);
+#endif
+  do {} while (data->fio[MESGSTATUS] & MESG_BUSY);
+  data->fio[MESGDSTCTRL] = MESG_DSTENB | MESG_DSTBPP_16;
+  data->fio[MESGDSTADDR] = 0x3101000;
+  data->fio[MESGDSTSTRIDE] = 4;
+  data->fio[MESGSRCCTRL] = MESG_SRCBPP_16 | MESG_INVIDEO;
+  data->fio[MESGPATCTRL] = MESG_PATENB | MESG_PATBPP_1;
+  data->fio[MESGFORCOLOR] = ~0;
+  data->fio[MESGBACKCOLOR] = ~0;
+  data->fio[MESGSIZE] = (1 << MESG_HEIGHT) | 32;
+  data->fio[MESGCTRL] = MESG_FFCLR | MESG_XDIR_POS | MESG_YDIR_POS | 0xAA;
+  asm volatile ("":::"memory");
+  data->fio[MESGSTATUS] = MESG_BUSY;
+  do {} while (data->fio[MESGSTATUS] & MESG_BUSY);
+}
+
+////
+// Flip between double-buffer pages
+//  - added: moved setting scaler in here too
+static int GP2X_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+  char *pixeldata;
+#ifdef GP2X_DEBUG
+  //  fprintf(stderr, "SDL_GP2X: Flip %p\n", surface);
+#endif
+  // make sure the blitter has finished
+  GP2X_WaitBusySurfaces(this);
+  GP2X_DummyBlit(this);
+  do {} while (data->fio[MESGSTATUS] & MESG_BUSY);
+
+  // MPO : waiting for vblank can be used by the YUV stuff too, so I moved it into a separate function
+  GP2X_WaitVBlank(data);
+
+  // Wait to be on even field (non-interlaced always returns 0)
+  //  do {} while (data->io[SC_STATUS] & SC_DISP_FIELD);
+
+  // set write address to be the page currently showing
+  surface->pixels = data->buffer_addr[data->buffer_showing];
+  // Flip buffers if need be
+  if (surface->flags & SDL_DOUBLEBUF)
+    data->buffer_showing = 1 - data->buffer_showing;
+
+  pixeldata = data->buffer_addr[data->buffer_showing] + data->ptr_offset;
+  if (data->phys_ilace) {
+    data->io[MLC_STL_OADRL] = GP2X_PhysL(this, pixeldata);
+    data->io[MLC_STL_OADRH] = GP2X_PhysH(this, pixeldata);
+    if (data->w == 720) pixeldata += data->pitch;
+  }
+  data->io[MLC_STL_EADRL] = GP2X_PhysL(this, pixeldata);
+  data->io[MLC_STL_EADRH] = GP2X_PhysH(this, pixeldata);
+
+  data->io[MLC_STL_HSC] = data->scale_x;
+  data->io[MLC_STL_VSCL] = data->scale_y & 0xffff;
+  data->io[MLC_STL_VSCH] = data->scale_y >> 16;
+
+  // Wait for vblank to end (to prevent 2 close page flips in one frame)
+  //  while (!(data->io[GPIOB_PINLVL] & GPIOB_VSYNC));
+  return 0;
+}
+
+////
+//
+static void GP2X_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+  // We're writing directly to video memory
+}
+
+////
+// Set HW palette (8-bit only)
+static int GP2X_SetColors(_THIS, int firstcolour, int ncolours,
+			  SDL_Color *colours)
+{
+  unsigned short volatile *memregs = this->hidden->io;
+  int i;
+#ifdef GP2X_DEBUG
+  //  fprintf(stderr, "SDL_GP2X: Setting %d colours, starting with %d\n",
+  //  	  ncolours, firstcolour);
+#endif
+  memregs[MLC_STL_PALLT_A] = firstcolour;
+  asm volatile ("":::"memory");
+  for (i = 0; i < ncolours; i++) {
+    memregs[MLC_STL_PALLT_D] = ((int)colours[i].g << 8) + colours[i].b;
+    asm volatile ("":::"memory");
+    memregs[MLC_STL_PALLT_D] = colours[i].r;
+    asm volatile ("":::"memory");
+  }
+  return 0;
+}
+
+////
+// Note:  If we are terminated, this could be called in the middle of
+//        another SDL video routine -- notably UpdateRects.
+static void GP2X_VideoQuit(_THIS)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+  int i;
+#ifdef GP2X_DEBUG
+  fputs("SDL_GP2X: VideoQuit\n", stderr);
+#endif
+
+  if (data->hw_lock) {
+    SDL_DestroyMutex(data->hw_lock);
+    data->hw_lock = NULL;
+  }
+
+  for (i = 0; i < SDL_NUMMODES; i++)
+    if (data->SDL_modelist[i]) {
+      free(data->SDL_modelist[i]);
+      data->SDL_modelist[i] = NULL;
+    }
+
+  GP2X_FreeHWSurfaces(this);
+
+//DKS - adding mouse close & keyboard close, they seemed to be missing
+	GP2X_CloseKeyboard(this);
+	GP2X_CloseMouse(this);
+}
+
+
+////
+// Check if blit between surfaces can be accelerated
+static int GP2X_CheckHWBlit(_THIS, SDL_Surface *src, SDL_Surface *dst)
+{
+#ifdef GP2X_DEBUG
+  //  fprintf(stderr, "SDL_GP2X: Checking HW accel of %p to %p... ", src, dst);
+#endif
+  // dst has to be HW to accelerate blits
+  // can't accelerate alpha blits
+  if ((dst->flags & SDL_HWSURFACE) && !(src->flags & SDL_SRCALPHA)) {
+    src->flags |= SDL_HWACCEL;
+    src->map->hw_blit = GP2X_HWAccelBlit;
+#ifdef GP2X_DEBUG
+    // fputs("Okay\n", stderr);
+#endif
+    return -1;
+  } else {
+    src->flags &= ~SDL_HWACCEL;
+#ifdef GP2X_DEBUG
+    // fputs("Nope\n", stderr);
+#endif
+    return 0;
+  }
+}
+
+////
+// Hardware accelerated fill
+static int GP2X_FillHWRect(_THIS, SDL_Surface *surface,
+			   SDL_Rect *area, Uint32 colour)
+{
+  Uint32 dstctrl, dest;
+  SDL_PrivateVideoData *data = this->hidden;
+#ifdef GP2X_DEBUG
+  /*
+  fprintf(stderr, "SDL_GP2X: FillHWRect %p (%d,%d)x(%d,%d) in %d\n",
+      	  surface, area->x, area->y, area->w, area->h, colour);
+  */
+#endif
+
+  if (surface == this->screen)
+    SDL_mutexP(data->hw_lock);
+
+  switch (surface->format->BitsPerPixel) {
+  case 8:
+    dstctrl = MESG_DSTBPP_8 | ((area->x & 0x03) << 3);
+    dest = GP2X_Phys(this, surface->pixels) +
+      (area->y * surface->pitch) + (area->x);
+    break;
+  case 16:
+    dstctrl = MESG_DSTBPP_16 | ((area->x & 0x01) << 4);
+    dest = GP2X_Phys(this, surface->pixels) +
+      (area->y * surface->pitch) + (area->x << 1);
+    break;
+  default:
+    SDL_SetError("SDL: GP2X can't hardware FillRect to surface");
+    return -1;
+    break;
+  }
+  do {} while (data->fio[MESGSTATUS] & MESG_BUSY);
+  data->fio[MESGDSTCTRL] = dstctrl;
+  data->fio[MESGDSTADDR] = dest & ~3;
+  data->fio[MESGDSTSTRIDE] = surface->pitch;
+  data->fio[MESGSRCCTRL] = 0;
+  data->fio[MESGPATCTRL] = MESG_PATENB | MESG_PATBPP_1;
+  data->fio[MESGFORCOLOR] = colour;
+  data->fio[MESGBACKCOLOR] = colour;
+  data->fio[MESGSIZE] = (area->h << MESG_HEIGHT) | area->w;
+  data->fio[MESGCTRL] = MESG_FFCLR | MESG_XDIR_POS | MESG_YDIR_POS | MESG_ROP_PAT;
+  asm volatile ("":::"memory");
+  data->fio[MESGSTATUS] = MESG_BUSY;
+
+  GP2X_AddBusySurface(surface);
+
+  if (surface == this->screen)
+    SDL_mutexV(data->hw_lock);
+  return 0;
+}
+
+////
+// Accelerated blit, 1->8, 1->16, 8->8, 16->16
+static int GP2X_HWAccelBlit(SDL_Surface *src, SDL_Rect *src_rect,
+			    SDL_Surface *dst, SDL_Rect *dst_rect)
+{
+  SDL_VideoDevice *this = current_video;
+  SDL_PrivateVideoData *data = this->hidden;
+  int w, h, src_x, src_y, src_stride, dst_stride, dst_x, dst_y;
+  Uint32 ctrl, src_start, dst_start, src_ctrl, dst_ctrl;
+  Uint32 *read_addr;
+#ifdef GP2X_DEBUG
+  /*
+  fprintf(stderr, "SDL_GP2X: HWBlit src:%p (%d,%d)x(%d,%d) -> %p (%d,%d)\n",
+    	  src, src_rect->x, src_rect->y, src_rect->w, src_rect->h,
+    	  dst, dst_rect->x, dst_rect->y);
+  */
+#endif
+
+  if (dst == this->screen)
+    SDL_mutexP(data->hw_lock);
+
+  src_x = src_rect->x;
+  src_y = src_rect->y;
+  dst_x = dst_rect->x;
+  dst_y = dst_rect->y;
+  w = src_rect->w;
+  h = src_rect->h;
+  src_stride = src->pitch;
+  dst_stride = dst->pitch;
+
+  // set blitter control with ROP and colourkey
+  ctrl = MESG_ROP_COPY | MESG_FFCLR;
+  if (src->flags & SDL_SRCCOLORKEY)
+    ctrl |= MESG_TRANSPEN | (src->format->colorkey << MESG_TRANSPCOLOR);
+
+  // In the case where src == dst, reverse blit direction if need be
+  //  to cope with potential overlap.
+  if (src != dst)
+    ctrl |= MESG_XDIR_POS | MESG_YDIR_POS;
+  else {
+    // if src rightof dst, blit left->right else right->left
+    if (src_x >= dst_x)
+      ctrl |= MESG_XDIR_POS;
+    else {
+      src_x += w - 1;
+      dst_x += w - 1;
+    }
+    // likewise, if src below dst blit top->bottom else bottom->top
+    if (src_y >= dst_y)
+      ctrl |= MESG_YDIR_POS;
+    else {
+      src_y += h - 1;
+      dst_y += h - 1;
+      src_stride = -src_stride;
+      dst_stride = -dst_stride;
+    }
+  }
+
+  if (dst->format->BitsPerPixel == 8) {
+    dst_start = GP2X_Phys(this, dst->pixels) + (dst_y * dst->pitch) + dst_x;
+    dst_ctrl = MESG_DSTBPP_8 | (dst_start & 0x03) << 3;
+  } else {
+    dst_start = GP2X_Phys(this, dst->pixels) +(dst_y*dst->pitch) +(dst_x<<1);
+    dst_ctrl = MESG_DSTBPP_16 | (dst_start & 0x02) << 3;
+  }
+  do {} while (data->fio[MESGSTATUS] & MESG_BUSY);
+  data->fio[MESGDSTCTRL] = dst_ctrl;
+  data->fio[MESGDSTADDR] = dst_start & ~3;
+  data->fio[MESGDSTSTRIDE] = dst_stride;
+  data->fio[MESGFORCOLOR] = data->src_foreground;
+  data->fio[MESGBACKCOLOR] = data->src_background;
+  data->fio[MESGPATCTRL] = 0;
+  data->fio[MESGSIZE] = (h << MESG_HEIGHT) | w;
+  data->fio[MESGCTRL] = ctrl;
+
+  ////// STILL TO CHECK SW->HW BLIT & 1bpp BLIT
+  if (src->flags & SDL_HWSURFACE) {
+    // src HW surface needs mapping from virtual -> physical
+    switch (src->format->BitsPerPixel) {
+    case 1:
+      src_start = GP2X_Phys(this, src->pixels) +(src_y*src->pitch) +(src_x>>3);
+      src_ctrl = MESG_SRCBPP_1 | (src_x & 0x1f);
+      break;
+    case 8:
+      src_start = GP2X_Phys(this, src->pixels) + (src_y * src->pitch) + src_x;
+      src_ctrl = MESG_SRCBPP_8 | (src_start & 0x03) << 3;
+      break;
+    case 16:
+      src_start = GP2X_Phys(this, src->pixels) +(src_y*src->pitch) +(src_x<<1);
+      src_ctrl = MESG_SRCBPP_16 | (src_start & 0x02) << 3;
+      break;
+    default:
+      SDL_SetError("Invalid bit depth for GP2X_HWBlit");
+      return -1;
+    }
+    data->fio[MESGSRCCTRL] = src_ctrl | MESG_SRCENB | MESG_INVIDEO;
+    data->fio[MESGSRCADDR] = src_start & ~3;
+    data->fio[MESGSRCSTRIDE] = src_stride;
+    asm volatile ("":::"memory");
+    data->fio[MESGSTATUS] = MESG_BUSY;
+  } else {
+    // src SW surface needs CPU to pump blitter
+    int src_int_width, frac;
+    switch (src->format->BitsPerPixel) {
+    case 1:
+      src_start = (Uint32)src->pixels + (src_y * src->pitch) + (src_x >> 3);
+      frac = src_x & 0x1f;
+      src_ctrl = MESG_SRCENB | MESG_SRCBPP_1 | frac;
+      src_int_width = (frac + w + 31) / 32;
+      break;
+    case 8:
+      src_start = (Uint32)src->pixels + (src_y * src->pitch) + src_x;
+      frac = (src_start & 0x03) << 3;
+      src_ctrl = MESG_SRCENB | MESG_SRCBPP_8 | frac;
+      src_int_width = (frac + w*8 + 31) / 32;
+      break;
+    case 16:
+      src_start = (Uint32)src->pixels + (src_y * src->pitch) + (src_x << 1);
+      frac = (src_start & 0x02) << 3;
+      src_ctrl = MESG_SRCENB | MESG_SRCBPP_16 | frac;
+      src_int_width = (frac + w*16 + 31) / 32;
+      break;
+    default:
+      SDL_SetError("Invalid bit depth for GP2X_HWBlit");
+      return -1;
+    }
+    data->fio[MESGSRCCTRL] = src_ctrl;
+    asm volatile ("":::"memory");
+    data->fio[MESGSTATUS] = MESG_BUSY;
+
+    while (--h) {
+      int i = src_int_width;
+      read_addr = (Uint32 *)(src_start & ~3);
+      src_start += src_stride;
+      if (ctrl & MESG_XDIR_POS)
+	while (--i)
+	  data->fio[MESGFIFO] = 0xff; //*read_addr++;
+      else
+	while (--i)
+	  data->fio[MESGFIFO] = 0x80; //*read_addr--;
+    }
+  }
+
+  GP2X_AddBusySurface(src);
+  GP2X_AddBusySurface(dst);
+
+  if (dst == this->screen)
+    SDL_mutexV(data->hw_lock);
+
+  return 0;
+}
+
+////
+// HW cursor support
+
+// Support routine to fill cursor data
+static void fill_cursor_data(Uint16 *cursor, int w, int h, int size,
+			     int skip, Uint8 *data, Uint8 *mask)
+{
+  Uint16 *cursor_addr = cursor;
+  Uint16 *cursor_end  = cursor + size;
+  int x, y, datab, maskb, pixel, i, dimension;
+  //############
+  //######
+  //###### HW LACE NEEDS FIXING
+  //######
+  //############
+  dimension = (size == 256 ? 32 : 64);
+  if (skip) skip = dimension << 4;
+  for (y = 0; y < h; y++) {
+    for (x = 0; x < w; x += 8) {
+      datab = *data++;
+      maskb = *mask++;
+      pixel = 0;
+      for (i = 8; i; i--) {
+	pixel <<= 2;
+	if (!(maskb & 0x01))
+	  pixel |= 0x02;
+	else if (!(datab & 0x01))
+	  pixel |= 0x01;
+	maskb >>= 1;
+	datab >>= 1;
+      }
+      *cursor_addr++ = pixel;
+    }
+    while (x < dimension) {
+      *cursor_addr++ = 0xAAAA;
+      x += 8;
+    }
+    if (skip) {
+      cursor_addr += skip;
+      data += 4;
+      mask += 4;
+      y++;
+    }
+  }
+  while(cursor_addr < cursor_end)
+    *cursor_addr++ = 0xAAAA;
+}
+
+// Create cursor in HW format
+static WMcursor *GP2X_CreateWMCursor(SDL_VideoDevice *video,
+				     Uint8 *data, Uint8 *mask,
+				     int w, int h,
+				     int hot_x, int hot_y)
+{
+  SDL_PrivateVideoData *pvd = video->hidden;
+  int cursor_size, cursor_dimension, x, y, i;
+  Uint16 *cursor_addr, *cursor_end;
+  Uint16 pixel;
+  Uint8 datab, maskb;
+  SDL_WMcursor *cursor;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: Creating cursor %dx%d\n", w, h);
+#endif
+
+  // HW only supports 32x32 or 64x64. Pick smallest possible or crop
+  cursor_dimension = ((w < h) ? h : w) <= 32 ? 32 : 64;
+  cursor_size = cursor_dimension * cursor_dimension / 4;
+  if (!(cursor = (SDL_WMcursor*)malloc(sizeof *cursor))) {
+    SDL_OutOfMemory();
+    return NULL;
+  }
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: Allocated WMcursor @ %p (%d)\n",
+	  cursor, cursor_dimension);
+#endif
+
+  if (!(cursor->bucket = GP2X_SurfaceAllocate(video, cursor_size))) {
+    free(cursor);
+    return NULL;
+  }
+
+  cursor->dimension = cursor_dimension;
+  cursor->fgr = 0xffff;
+  cursor->fb = 0xff;
+  cursor->bgr = 0x0000;
+  cursor->bb = 0x00;
+  cursor->falpha = 0xf;
+  cursor->balpha = 0xf;
+
+  cursor_addr = (Uint16*)cursor->bucket->base;
+  if (pvd->phys_ilace) {
+    fill_cursor_data(cursor_addr, w, h, cursor_size, 1, data, mask);
+    fill_cursor_data(cursor_addr + (cursor_size << 1), w, h, cursor_size, 1, data + (cursor_dimension << 4), mask + (cursor_dimension << 4));
+  } else {
+    fill_cursor_data(cursor_addr, w, h, cursor_size, 0, data, mask);
+  }
+  return (WMcursor*)cursor;
+}
+
+////
+// Free the cursor memory
+static void GP2X_FreeWMCursor(_THIS, WMcursor *wmcursor)
+{
+  SDL_WMcursor *cursor = (SDL_WMcursor*)wmcursor;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "SDL_GP2X: Freeing cursor %p\n", cursor);
+#endif
+  if (cursor->bucket)
+    GP2X_SurfaceFree(this, cursor->bucket);
+  free(cursor);
+}
+
+////
+// Change HW cursor to passed, NULL to turn cursor off
+static int GP2X_ShowWMCursor(_THIS, WMcursor *wmcursor)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+  unsigned short volatile *io = data->io;
+  SDL_WMcursor *cursor = (SDL_WMcursor*)wmcursor;
+
+  data->visible_cursor = cursor;
+  if (cursor) {
+    io[MLC_HWC_OADRL] = io[MLC_HWC_EADRL] =
+      GP2X_PhysL(this, cursor->bucket->base);
+    io[MLC_HWC_OADRH] = io[MLC_HWC_EADRH] =
+      GP2X_PhysH(this, cursor->bucket->base);
+    io[MLC_HWC_FGR] = cursor->fgr;
+    io[MLC_HWC_FB] = cursor->fb;
+    io[MLC_HWC_BGR] = cursor->bgr;
+    io[MLC_HWC_BB] = cursor->bb;
+    io[MLC_HWC_CNTL] = (cursor->falpha << 12) |
+      (cursor->balpha << 8) |
+      cursor->dimension;
+    io[MLC_OVLAY_CNTR] |= DISP_CURSOR;
+    return -1;
+  } else
+    io[MLC_OVLAY_CNTR] &= ~DISP_CURSOR;
+  return 0;
+}
+
+////
+// Set colour & alpha of a cursor (alpha is 0-15)
+void SDL_GP2X_SetCursorColour(SDL_Cursor *scursor,
+			      int bred, int bgreen, int bblue, int balpha,
+			      int fred, int fgreen, int fblue, int falpha)
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+  SDL_WMcursor *cursor = (SDL_WMcursor*)scursor->wm_cursor;
+
+  cursor->fgr = ((fgreen & 0xFF) << 8) | (fred & 0xFF);
+  cursor->fb = fblue & 0xFF;
+  cursor->bgr = ((bgreen &0xFF) << 8) | (bred & 0xFF);
+  cursor->bb = bblue & 0xFF;
+  cursor->falpha = falpha & 0x0F;
+  cursor->balpha = balpha & 0x0F;
+
+  if (cursor == data->visible_cursor) {
+    data->io[MLC_HWC_FGR] = cursor->fgr;
+    data->io[MLC_HWC_FB] =  cursor->fb;
+    data->io[MLC_HWC_BGR] = cursor->bgr;
+    data->io[MLC_HWC_BB] =  cursor->bb;
+    data->io[MLC_HWC_CNTL] = (cursor->falpha << 12) |
+      (cursor->balpha << 8) |
+      cursor->dimension;
+  }
+}
+
+
+////
+// Move the cursor to specified (physical) coordinate
+static void GP2X_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+
+  data->cursor_px = x;
+  data->cursor_py = y;
+  //  data->io[MLC_HWC_STX] = x;
+  //  data->io[MLC_HWC_STY] = y;
+  SDL_PrivateMouseMotion(0, 0, x, y);
+}
+
+////
+// Move the cursor to (virtual) coordinate
+static void GP2X_MoveWMCursor(_THIS, int x, int y)
+{
+  SDL_PrivateVideoData *data = this->hidden;
+
+  data->cursor_vx = x;
+  data->cursor_vy = y;
+  // convert virtual coordinate into physical
+  x = ((x - data->x_offset) * data->xscale) >> 16;
+  y = ((y - data->y_offset) * data->yscale) >> 16;
+  data->cursor_px = x;
+  data->cursor_py = y;
+  data->io[MLC_HWC_STX] = x;
+  data->io[MLC_HWC_STY] = y;
+}
+
+
+////////
+// GP2X specific functions -
+
+////
+// Set foreground & background colours for 1bpp blits
+void SDL_GP2X_SetMonoColours(int background, int foreground)
+{
+  if (current_video) {
+    current_video->hidden->src_foreground = foreground;
+    current_video->hidden->src_background = background;
+  }
+}
+
+////
+// Enquire physical screen size - for detecting LCD / TV
+//  Returns 0: Progressive
+//          1: Interlaced
+int SDL_GP2X_GetPhysicalScreenSize(SDL_Rect *size)
+{
+  if (current_video) {
+    SDL_PrivateVideoData *data = current_video->hidden;
+    size->w = data->phys_width;
+    size->h = data->phys_height;
+    return data->phys_ilace;
+  }
+  return -1;
+}
+
+////
+// Dynamic screen scaling
+void SDL_GP2X_Display(SDL_Rect *area)
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+  int sc_x, sc_y;
+
+  // If top-left is out of bounds then correct it
+  if (area->x < 0)
+    area->x = 0;
+  if (area->x > (data->w - 8))
+    area->x = data->w - 8;
+  if (area->y < 0)
+    area->y = 0;
+  if (area->y > (data->h - 8))
+    area->y = data->h - 8;
+  // if requested area is wider than screen, reduce width
+  if (data->w < (area->x + area->w))
+    area->w = data->w - area->x;
+  // if requested area is taller than screen, reduce height
+  if (data->h < (area->y + area->h))
+    area->h = data->h - area->y;
+
+  data->xscale = (data->phys_width << 16) / area->w;
+  data->yscale = (data->phys_height << 16) / area->h;
+  data->invxscale = (area->w << 16) / data->phys_width;
+  data->invyscale = (area->h << 16) / data->phys_height;
+  sc_x = (1024 * area->w) / data->phys_width;
+  sc_y = (area->h * data->pitch) / data->phys_height;
+  // Evil hacky thing. Scaler only works if horiz needs scaling.
+  // If requested scale only needs to scale in vertical, fudge horiz
+  if ((sc_x == 1024) && (area->h != data->phys_height))
+    sc_x++;
+
+  data->scale_x = sc_x;
+  data->scale_y = sc_y;
+  data->x_offset = area->x;
+  data->y_offset = area->y;
+  data->ptr_offset = ((area->y * data->pitch) +
+		      (area->x *current_video->info.vfmt->BytesPerPixel)) & ~3;
+
+  // Apply immediately if we're not double-buffered
+  if (!(current_video->screen->flags & SDL_DOUBLEBUF)) {
+    char *pixeldata = data->buffer_addr[data->buffer_showing]+data->ptr_offset;
+    if (data->phys_ilace) {
+      data->io[MLC_STL_OADRL] = GP2X_PhysL(current_video, pixeldata);
+      data->io[MLC_STL_OADRH] = GP2X_PhysH(current_video, pixeldata);
+      if (data->w == 720) pixeldata += data->pitch;
+    }
+    data->io[MLC_STL_EADRL] = GP2X_PhysL(current_video, pixeldata);
+    data->io[MLC_STL_EADRH] = GP2X_PhysH(current_video, pixeldata);
+    data->io[MLC_STL_HSC] = data->scale_x;
+    data->io[MLC_STL_VSCL] = data->scale_y & 0xffff;
+    data->io[MLC_STL_VSCH] = data->scale_y >> 16;
+  }
+}
+
+////
+// window region routines -
+//
+// Set region area.
+//   region = which hw region 1-4
+//   area   = coords of area
+void SDL_GP2X_DefineRegion(int region, SDL_Rect *area)
+{
+  if ((region >= 1) && (region <= 4) && (area)) {
+    SDL_PrivateVideoData *data = current_video->hidden;
+    unsigned short volatile *region_reg;
+
+    region_reg = &data->io[MLC_STL1_STX + (region - 1) * 4];
+    *region_reg++ = area->x;
+    *region_reg++ = area->x + area->w - 1;
+    *region_reg++ = area->y;
+    *region_reg++ = area->y + area->h - 1;
+  }
+}
+
+// (De)activate region
+void SDL_GP2X_ActivateRegion(int region, int activate)
+{
+  if ((region >= 1) && (region <= 5)) {
+    SDL_PrivateVideoData *data = current_video->hidden;
+    int stl_region_bit = 1 >> ((region - 1) * 2);
+    int ovlay_region_bit = 1 >> (region + 1);
+
+    if (activate) {
+      data->io[MLC_STL_CNTL] |= stl_region_bit;
+      data->io[MLC_OVLAY_CNTR] |= ovlay_region_bit;
+    } else {
+      data->io[MLC_STL_CNTL] &= ~stl_region_bit;
+      data->io[MLC_OVLAY_CNTR] &= ~ovlay_region_bit;
+    }
+  }
+}
+
+// Allow a smaller screen than the display, without scaling
+void SDL_GP2X_MiniDisplay(int x, int y)
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+  SDL_Rect mini_region;
+
+  // Set scaler back to 1:1
+  data->scale_x = 1024;
+  data->scale_y = data->phys_pitch;
+  data->xscale = data->yscale = 1<<16;
+  data->invxscale = data->invyscale = 1<<16;
+  // offsets needed to start screen at (x,y)
+  data->x_offset = -x;
+  data->y_offset = -y;
+  data->ptr_offset = -((y * data->pitch) +
+		       (x *current_video->info.vfmt->BytesPerPixel)) & ~3;
+  // Apply immediately if we're not double-buffered
+  if (!(current_video->screen->flags & SDL_DOUBLEBUF)) {
+    char *pixeldata = data->buffer_addr[data->buffer_showing]+data->ptr_offset;
+    if (data->phys_ilace) {
+      data->io[MLC_STL_OADRL] = GP2X_PhysL(current_video, pixeldata);
+      data->io[MLC_STL_OADRH] = GP2X_PhysH(current_video, pixeldata);
+      if (data->w == 720) pixeldata += data->pitch;
+    }
+    data->io[MLC_STL_EADRL] = GP2X_PhysL(current_video, pixeldata);
+    data->io[MLC_STL_EADRH] = GP2X_PhysH(current_video, pixeldata);
+    data->io[MLC_STL_HSC] = 1024;
+    data->io[MLC_STL_VSCL] = data->scale_y & 0xffff;
+    data->io[MLC_STL_VSCH] = data->scale_y >> 16;
+  }
+
+  mini_region.x = x;
+  mini_region.y = y;
+  mini_region.w = data->w;
+  mini_region.h = data->h;
+  SDL_GP2X_DefineRegion(1, &mini_region);
+}
+
+// Lets the user wait for the blitter to finish
+void SDL_GP2X_WaitForBlitter()
+{
+  GP2X_WaitBusySurfaces(current_video);
+}
+
+static int tv_device = 0;
+
+// Switch TV mode on/off, and set position & offsets
+int SDL_GP2X_TV(int state)
+{
+  if (state == 0) {   // Turn TV off
+    if (tv_device) {  // close device to return to LCD
+#ifdef GP2X_DEBUG
+      fputs("Closing CX25874\n", stderr);
+#endif
+      close(tv_device);
+      tv_device = 0;
+    }
+    return 0;
+  }
+
+  // Turn TV on
+  if (!tv_device) {  // open device to enable TV
+#ifdef GP2X_DEBUG
+    fputs("Opening CX25874\n", stderr);
+#endif
+    tv_device = open("/dev/cx25874", O_RDWR, 0);
+    if (!tv_device) {
+      SDL_SetError("Failed to open TV device.");
+      return 0;
+    }
+  }
+  return 1;
+}
+
+int SDL_GP2X_TVMode(int mode)
+{
+  // No device open, or mode is out of range
+  if ((!tv_device) || (mode < 1) || (mode > 5))
+    return -1;
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "Switching tv mode to %d\n", mode);
+#endif
+  ioctl(tv_device, IOCTL_CX25874_DISPLAY_MODE_SET, mode);
+  return 0;
+}
+
+void SDL_GP2X_TVAdjust(int direction)
+{
+  if ((!tv_device) || (direction < 0) || (direction > 3))
+    return;
+
+#ifdef GP2X_DEBUG
+  fprintf(stderr, "Moving TV by %d\n", direction);
+#endif
+  ioctl(tv_device, IOCTL_CX25874_TV_MODE_POSITION, direction);
+}
+
+////
+// Mark gfx memory as allowed
+void SDL_GP2X_AllowGfxMemory(char *start, int size)
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+  char *end = start + size;
+  char *block = (char*)GP2X_UPPER_MEM_START;  // Start of upper memory
+
+  data->allow_scratch_memory = 1;
+}
+
+
+void SDL_GP2X_DenyGfxMemory(char *start, int size)
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+  data->allow_scratch_memory = 0;
+}
+
+
+void SDL_GP2X_VSync()
+{
+  SDL_PrivateVideoData *data = current_video->hidden;
+
+  GP2X_WaitVBlank(data);
+}
+
+
+// Return a hardware surface's bitmap address for use by the 940
+//  Surface has to be SDL_HWSURFACE *and* SDL_LockSurface()ed
+//  When you unlock the surface the address you got from here *must*
+//  be considered invalid.
+void *SDL_GP2X_PhysAddress(SDL_Surface *surface)
+{
+  void *address = NULL;
+
+  // return null if null pointer passed, or surface is not locked
+  if ((!surface) || (!surface->locked))
+    SDL_SetError("Invalid or unlocked surface passed");
+  else if (!(surface->flags & SDL_HWSURFACE))
+    SDL_SetError("PhysAddress() only valid for hardware surfaces");
+  else
+    address = (void*)GP2X_Phys(current_video, surface->pixels);
+
+  return address;
+}
+
+
+// Query gp2x mouse type (none = 0, std = 1, touchscreen = 2)
+int SDL_GP2X_MouseType()
+{
+  return current_video->hidden->mouse_type;
+}
+
+
+// Get (semi-)raw touchpad position (not SDL position)
+//   0 <= x <= 319, 0 <= y <= 239
+//   Return value is pressure (any non zero value means pressed)
+int SDL_GP2X_Touchpad(int *x, int *y)
+{
+  if (x) *x = current_video->hidden->touch_x;
+  if (y) *y = current_video->hidden->touch_y;
+  return current_video->hidden->touch_pressure;
+}
+
+// Enable (1) or disable (0) the touchscreen stylus from causing mouse button events.  
+// In some games/apps it is desirable to have the stylus only used for positioning of
+// the cursor with clicking done by joystick buttons. Default is enabled.
+void SDL_GP2X_TouchpadMouseButtonEvents(int enabled)
+{
+	if (current_video->hidden->mouse_type == 2)
+	{
+		current_video->hidden->mouse_button_events_enabled = enabled ? 1:0;
+	}
+}
+
+// Enable (1) or disable (0) the touchscreen stylus from causing mouse motion events or
+// registering changes in cursor state.  Sometimes a developer may wish to easily
+// disable the touchscreen and not have to modify large sections of code in a porting
+// project. Default is enabled.
+void SDL_GP2X_TouchpadMouseMotionEvents(int enabled)
+{
+	if (current_video->hidden->mouse_type == 2)
+	{
+		current_video->hidden->mouse_motion_events_enabled = enabled ? 1:0;
+	}
+}
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xvideo.h SDL-1.2.11/src/video/gp2x/SDL_gp2xvideo.h
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xvideo.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xvideo.h	2020-04-13 13:05:31.942199134 +0200
@@ -0,0 +1,244 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ "@(#) $Id: $";
+#endif
+
+#ifndef _SDL_gp2xvideo_h
+#define _SDL_gp2xvideo_h
+
+#include <sys/types.h>
+#include <termios.h>
+
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_mutex.h"
+
+#include "mmsp2_regs.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *this
+
+// Allocate 5MB for the frame buffer (seems to be how gph have it)
+//#define GP2X_VIDEO_MEM_SIZE ((5*1024*1024) - 4096)
+
+// New memory allocation, VIDEO_MEM is now the entire upper 32MB with
+//  the reserved parts marked internally as unusable.
+//  OFFSET is from base of video memory to start of fbcon0
+#define GP2X_VIDEO_MEM_SIZE (32*1024*1024)
+#define GP2X_SCREEN_OFFSET 0
+//0x1101000
+
+// This is used in both gp2xvideo and gp2xyuv, so I put it here to make maintenance easier
+#define GP2X_UPPER_MEM_START 0x2000000
+
+// Number of native modes supported
+#define SDL_NUMMODES 8
+
+// TV control
+#define IOCTL_CX25874_DISPLAY_MODE_SET	_IOW('v', 0x02, unsigned char)
+#define IOCTL_CX25874_TV_MODE_POSITION	_IOW('v', 0x0A, unsigned char)
+
+#define TV_POS_LEFT	0
+#define TV_POS_RIGHT	1
+#define TV_POS_UP	2
+#define TV_POS_DOWN	3
+
+
+#define CX25874_ID 	0x8A
+
+#define DISPLAY_LCD     0x1
+#define DISPLAY_MONITOR 0x2
+#define DISPLAY_TV_NTSC 0x3
+#define DISPLAY_TV_PAL 	0x4
+#define DISPLAY_TV_GAME_NTSC 0x05
+
+
+////
+// Internal structure for allocating video memory
+typedef struct video_bucket {
+  struct video_bucket *prev, *next;
+  char *base;
+  unsigned int size;
+  short used;
+  short dirty;
+} video_bucket;
+
+////
+// Internal structure for hardware cursor
+typedef struct SDL_WMcursor {
+  video_bucket *bucket;
+  int dimension;
+  unsigned short fgr, fb, bgr, bb, falpha, balpha;
+} SDL_WMcursor;
+
+////
+// Private display data
+
+//DKS - disabled in favor of newer code from 1.2.9
+//typedef struct SDL_PrivateVideoData {
+//  int memory_fd, fbcon_fd, mouse_fd, keyboard_fd;
+//  int saved_keybd_mode;
+//  int mouse_type;
+//  //  struct termios saved_kbd_termios;
+//  int x_offset, y_offset, ptr_offset;
+//  int w, h, pitch;
+//  int vsync_polarity;
+//  int phys_width, phys_height, phys_pitch, phys_ilace;
+//  int scale_x, scale_y;
+//  int xscale, yscale;
+//  int invxscale, invyscale;
+//  SDL_mutex *hw_lock;
+//  unsigned short fastioclk, grpclk;
+//  unsigned short src_foreground, src_background;
+//  char *vmem;
+//  int buffer_showing;
+//  char *buffer_addr[2];
+//  unsigned short volatile *io;
+//  unsigned int volatile *fio;
+//  video_bucket video_mem;
+//  char *surface_mem;
+//  int memory_left;
+//  int memory_max;
+//  int allow_scratch_memory;
+//  SDL_WMcursor *visible_cursor;
+//  int cursor_px, cursor_py, cursor_vx, cursor_vy;
+//  SDL_Rect *SDL_modelist[SDL_NUMMODES+1];
+//  unsigned short stl_cntl, stl_mixmux, stl_alphal, stl_alphah;
+//  unsigned short stl_hsc, stl_vscl, stl_vsch, stl_hw;
+//  unsigned short stl_oadrl, stl_oadrh, stl_eadrl, stl_eadrh;
+//  unsigned short stl_regions[16]; // 1<=x<=4 of STLx_STX, _ENDX, _STY, _ENDY
+//  unsigned short mlc_ovlay_cntr;
+//} SDL_PrivateVideoData;
+typedef struct SDL_PrivateVideoData {
+  int memory_fd, fbcon_fd, mouse_fd, keyboard_fd;
+  int saved_kbd_mode;
+  int current_vt;
+  int saved_vt;
+  int mouse_type;
+  //senquack - new options
+  int mouse_button_events_enabled;	/* User-configurable option.  default = 1: post mouse
+													button events when stylus goes up or down.  
+													0:  don't post button events 								*/
+  int mouse_motion_events_enabled;	/* User-configurable option.  default = 1: post mouse
+													motion events when stylus is down
+													0:  don't post motion events 								*/
+  struct tsdev *ts_dev;
+  struct termios saved_kbd_termios;
+  int touch_x, touch_y, touch_pressure;
+  int x_offset, y_offset, ptr_offset;
+  int w, h, pitch;
+  int vsync_polarity;
+  int phys_width, phys_height, phys_pitch, phys_ilace;
+  int scale_x, scale_y;
+  int xscale, yscale;
+  int invxscale, invyscale;
+  SDL_mutex *hw_lock;
+  unsigned short fastioclk, grpclk;
+  unsigned short src_foreground, src_background;
+  char *vmem;
+  int buffer_showing;
+  char *buffer_addr[2];
+  unsigned short volatile *io;
+  unsigned int volatile *fio;
+  video_bucket video_mem;
+  char *surface_mem;
+  int memory_left;
+  int memory_max;
+  int allow_scratch_memory;
+  SDL_WMcursor *visible_cursor;
+  int cursor_px, cursor_py, cursor_vx, cursor_vy;
+  SDL_Rect *SDL_modelist[SDL_NUMMODES+1];
+  unsigned short stl_cntl, stl_mixmux, stl_alphal, stl_alphah;
+  unsigned short stl_hsc, stl_vscl, stl_vsch, stl_hw;
+  unsigned short stl_oadrl, stl_oadrh, stl_eadrl, stl_eadrh;
+  unsigned short stl_regions[16]; // 1<=x<=4 of STLx_STX, _ENDX, _STY, _ENDY
+  unsigned short mlc_ovlay_cntr;
+} SDL_PrivateVideoData;
+
+extern VideoBootStrap GP2X_bootstrap;
+
+////
+// utility functions
+////
+
+////
+// convert virtual address to physical
+static inline unsigned int GP2X_Phys(_THIS, char *virt)
+{
+  return (unsigned int)((long)virt - (long)(this->hidden->vmem) + 0x2000000);
+}
+
+////
+// convert virtual address to physical (lower word)
+static inline unsigned short GP2X_PhysL(_THIS, char *virt)
+{
+  return (unsigned short)(((long)virt - (long)(this->hidden->vmem) + 0x2000000) & 0xffff);
+}
+
+////
+// convert virtual address to phyical (upper word)
+static inline unsigned short GP2X_PhysH(_THIS, char *virt)
+{
+  return (unsigned short)(((long)virt - (long)(this->hidden->vmem) + 0x2000000) >> 16);
+}
+
+////
+// mark surface has been used in HW accel
+static inline void GP2X_AddBusySurface(SDL_Surface *surface)
+{
+  ((video_bucket *)surface->hwdata)->dirty = 1;
+}
+
+////
+// test if surface has been used in HW accel
+static inline int GP2X_IsSurfaceBusy(SDL_Surface *surface)
+{
+  return ((video_bucket *)surface->hwdata)->dirty;
+}
+
+////
+// wait for blitter to finish with all busy surfaces
+static inline void GP2X_WaitBusySurfaces(_THIS)
+{
+  video_bucket *bucket;
+
+  for (bucket = &this->hidden->video_mem; bucket; bucket = bucket->next)
+    bucket->dirty = 0;
+  do {} while (this->hidden->fio[MESGSTATUS] & MESG_BUSY);
+}
+
+// Waits until vblank is active (doesn't necessarily wait for vblank to start)
+static inline void GP2X_WaitVBlank(const SDL_PrivateVideoData *data)
+{
+ 	// wait for vblank to start, choose transition type by polarity
+ 	if (data->vsync_polarity)
+ 	  do {} while ((data->io[GPIOB_PINLVL] & GPIOB_VSYNC));
+ 	else
+ 	  do {} while (!(data->io[GPIOB_PINLVL] & GPIOB_VSYNC));
+}
+
+
+//#define GP2X_DEBUG 
+#endif // _SDL_gp2xvideo_h
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xyuv.c SDL-1.2.11/src/video/gp2x/SDL_gp2xyuv.c
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xyuv.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xyuv.c	2020-04-13 13:05:31.942199134 +0200
@@ -0,0 +1,457 @@
+/*
+    SDL - Simple DirectMedia Layer - SDL_gp2xyuv.c extension
+    Copyright (C) 2007 Matt Ownby
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* This is the GP2X implementation of YUV video overlays */
+
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>	// for open
+#include <sys/mman.h>	// for mmap
+#include <unistd.h>	// for close
+
+#ifdef GP2X_DEBUG
+	#include <assert.h>	// for self testing ...
+#endif // GP2X_DEBUG
+
+#include "SDL_error.h"
+#include "SDL_video.h"
+#include "SDL_gp2xyuv_c.h"
+#include "../SDL_yuvfuncs.h"
+#include "mmsp2_regs.h"
+//#include "arm_colorconv.h"
+
+/* The functions used to manipulate software video overlays */
+static struct private_yuvhwfuncs gp2x_yuvfuncs =
+{
+	GP2X_LockYUVOverlay,
+	GP2X_UnlockYUVOverlay,
+	GP2X_DisplayYUVOverlay,
+	GP2X_FreeYUVOverlay
+};
+
+struct private_yuvhwdata
+{
+	Uint8 *YUVBuf[2][3];	// we will have two buffers, a front and back (double buffered)
+	unsigned int GP2XAddr[2][3];	// the yuv buffer address from the gp2x's perspective
+	unsigned int uBackBuf;	// which buffer is currently the back buffer (0 or 1)
+	unsigned int uBufSize;	// how big the YUVBuf buffers are (in bytes)
+	unsigned int uYsize;	// how big the Y plane is (in bytes) (not used for YUY2)
+	unsigned int uUsize;	// how big the U plane is (in bytes) (not used for YUY2)
+	SDL_Rect rctLast;	// the last rectangle we used for displaying (so we know when to rescale/change coordinates)
+	Uint16 u16PixelWidth;	// value stored for MLC_VLA_TP_PXW register
+
+	/* These are just so we don't have to allocate them separately */
+	Uint16 pitches[3];
+	Uint8 *planes[3];
+	
+	Uint32 format;
+};
+
+#define FDC_CNTL (0x1838 >> 1)
+#define FDC_FRAME_SIZE (0x183A >> 1)
+#define FDC_LUMA_OFFSET (0x183C >> 1)
+#define FDC_CB_OFFSET (0x183E >> 1)
+#define FDC_CR_OFFSET (0x1840 >> 1)
+
+// These are the registers (currently) modified by this code;
+// They are in this array so we can restore them to their previous state after the overlay is destroyed.
+const unsigned int g_pTouchedRegs[] =
+{
+	MLC_OVLAY_CNTR,
+	0x2882 >> 1,
+	0x2884 >> 1,
+	0x2886 >> 1,
+	0x288A >> 1,
+	0x288C >> 1,
+	0x2892 >> 1,
+	0x2896 >> 1,
+	0x2898 >> 1,
+	0x289A >> 1,
+	0x289C >> 1,
+	0x289E >> 1,
+	0x28A0 >> 1,
+	0x28A2 >> 1,
+	0x28A4 >> 1,
+	0x28A6 >> 1,
+	0x28C0 >> 1,
+	0x28C2 >> 1,
+	FDC_CNTL,
+	FDC_FRAME_SIZE,
+	FDC_LUMA_OFFSET,
+	FDC_CB_OFFSET,
+	FDC_CR_OFFSET
+};
+
+const unsigned int TOUCHEDREGS_COUNT = sizeof(g_pTouchedRegs) / sizeof(unsigned int);
+
+// where we save the regs (compiler wouldn't let me use TOUCHEDREGS_COUNT in array)
+static unsigned short g_pu16SavedRegs[sizeof(g_pTouchedRegs) / sizeof(unsigned int)];
+
+#ifdef GP2X_DEBUG
+	// to test whether saving and restoring the regs is working
+	void *g_pRegTester = NULL;
+#endif // GP2X_DEBUG
+
+// saves or restores registers that are used by the YUV code depending on 'iSave'
+static void GP2X_SaveRestoreRegs(_THIS, int iSave)
+{
+	SDL_PrivateVideoData *data = this->hidden;
+	unsigned int u = 0;
+
+	for (u = 0; u < TOUCHEDREGS_COUNT; u++)
+	{
+		// if we're saving the registers
+		if (iSave)
+		{
+			g_pu16SavedRegs[u] = data->io[g_pTouchedRegs[u]];
+		}
+		// else we're restoring the registers
+		else
+		{
+			data->io[g_pTouchedRegs[u]] = g_pu16SavedRegs[u];
+		}
+	}
+}
+
+static int GP2X_SetupYUV(_THIS, int width, int height, Uint32 format, struct private_yuvhwdata *hwdata)
+{
+	int iSuccess = 0;
+	SDL_PrivateVideoData *data = this->hidden;
+	unsigned short volatile *p16GP2XRegs = data->io;
+
+	if(format == SDL_YUY2_OVERLAY)
+		hwdata->uBufSize = width * height * 2;	// YUY2 is (2 * width) bytes per line
+	else if(format == SDL_YV12_OVERLAY || format == SDL_IYUV_OVERLAY)
+		hwdata->uBufSize = width * height * 3 / 2;	// u v 2x2 subsampled -> width * 1.5 bytes per line
+
+	// initialize to values that will never be used so that we force a rescale the first time GP2X_DisplayYUVOverlay is called
+	hwdata->rctLast.h = hwdata->rctLast.w = 0;
+	hwdata->rctLast.x = hwdata->rctLast.y = -1;
+
+	hwdata->uBackBuf = 0;	// arbitrary starting point (can be 0 or 1)
+
+	if(format == SDL_YUY2_OVERLAY)
+	{
+		// We're using GP2X_UPPER_MEM_START because that's where vmem is mapped in SDL_gp2xvideo.c
+		hwdata->GP2XAddr[0][0] = GP2X_UPPER_MEM_START;	// this is where vmem is mapped from the gp2x's pov
+		hwdata->GP2XAddr[1][0] = GP2X_UPPER_MEM_START + hwdata->uBufSize;
+
+		//map memory for our cursor + 4 YUV regions (double buffered each one)
+		hwdata->YUVBuf[0][0] = (Uint8 *) data->vmem;
+		hwdata->YUVBuf[1][0] = ((Uint8 *) data->vmem) + hwdata->uBufSize;
+	}
+	else if(format == SDL_YV12_OVERLAY || format == SDL_IYUV_OVERLAY)
+	{
+		// PhyAddr = (ScreenOffset << 24) | (YOffset << 20) | (XOffset * 0x2000)
+
+		// GP2X_UPPER_MEM_START == 0x0200 << 24
+		hwdata->GP2XAddr[0][0] = 0x0240;	// this is from the gp2x's pov
+		hwdata->GP2XAddr[0][1] = 0x0244;
+		hwdata->GP2XAddr[0][2] = 0x0246;
+		hwdata->GP2XAddr[1][0] = 0x0260;
+		hwdata->GP2XAddr[1][1] = 0x0264;
+		hwdata->GP2XAddr[1][2] = 0x0266;
+
+		//map memory for our cursor + 4 YUV regions (double buffered each one)
+		hwdata->YUVBuf[0][0] = (Uint8 *) data->vmem + (0x4 << 20);
+		hwdata->YUVBuf[0][1] = (Uint8 *) data->vmem + (0x4 << 20) + 0x4 * 0x2000;
+		hwdata->YUVBuf[0][2] = (Uint8 *) data->vmem + (0x4 << 20) + 0x6 * 0x2000;
+		hwdata->YUVBuf[1][0] = (Uint8 *) data->vmem + (0x6 << 20);
+		hwdata->YUVBuf[1][1] = (Uint8 *) data->vmem + (0x6 << 20) + 0x4 * 0x2000;
+		hwdata->YUVBuf[1][2] = (Uint8 *) data->vmem + (0x6 << 20) + 0x6 * 0x2000;
+	}
+
+	hwdata->format = format;
+
+	// tests have shown that this value should be the width of the overlay, not the width of the display (ie not always 320)
+	hwdata->u16PixelWidth = width;
+
+	if(format != SDL_YUY2_OVERLAY)
+		p16GP2XRegs[FDC_CNTL] = 1<<11 + // Write mode: mem -> scaler/display
+		 ((format == SDL_YV12_OVERLAY || format == SDL_IYUV_OVERLAY) ? 1 : 0) << 1;
+
+	// Set MLC_VLA_TP_PXW
+	p16GP2XRegs[0x2892>>1] = hwdata->u16PixelWidth;
+
+	// MLC_YUV_CNTL: set YUV source to external memory for regions A and B, turn off "stepping" when YUY2
+	// otherwise get it from the fdc
+	p16GP2XRegs[0x2884>>1] = format == SDL_YUY2_OVERLAY ? 0 : 1;
+
+	// disable all RGB Windows, and YUV region A & B
+	p16GP2XRegs[MLC_OVLAY_CNTR] &= ~(DISP_STL5EN|DISP_STL4EN|DISP_STL3EN|DISP_STL2EN|DISP_STL1EN|DISP_VLAON|DISP_VLBON);
+
+	// disable bottom regions for A & B, and turn off all mirroring
+	p16GP2XRegs[0x2882>>1] &= 0xFC00;
+
+	// Region B is disabled so we (hopefully) don't need to set anything for it
+
+	// There currently is no way for this function to fail, but I'm leaving this in in case a future way presents itself
+	iSuccess = 1;
+
+	return iSuccess;
+}
+
+SDL_Overlay *GP2X_CreateYUVOverlay(_THIS, int width, int height, Uint32 format, SDL_Surface *display)
+{
+	SDL_Overlay *overlay = NULL;
+	struct private_yuvhwdata *hwdata;
+
+	switch(format){
+		// we support YUY2 because that is the native gp2x YUV format
+		case SDL_YUY2_OVERLAY:
+		// other planar formats need the extra frame dimension converter
+		case SDL_YV12_OVERLAY:
+		case SDL_IYUV_OVERLAY:	// == I420 ?
+			break;
+
+		default:
+			// SDL_UYVY_OVERLAY: // 2x2 subsampled packed
+			// SDL_YVYU_OVERLAY: // 2x2 subsampled packed
+			printf("SDL_GP2X: Unsupported YUV format for hardware acceleration. Falling back to software.\n");
+			return NULL;
+	}
+
+	/* Create the overlay structure */
+	overlay = (SDL_Overlay *)malloc(sizeof *overlay);
+	if ( overlay == NULL ) {
+		SDL_OutOfMemory();
+		return(NULL);
+	}
+	memset(overlay, 0, (sizeof *overlay));
+
+	/* Fill in the basic members */
+	overlay->format = format;
+	overlay->w = width;
+	overlay->h = height;
+
+	/* Set up the YUV surface function structure */
+	overlay->hwfuncs = &gp2x_yuvfuncs;
+
+	// save our registers
+	GP2X_SaveRestoreRegs(this, 1);
+
+#ifdef GP2X_DEBUG
+	// this is a self-test precaution
+	{
+		SDL_PrivateVideoData *data = this->hidden;
+		unsigned short volatile *p16GP2XRegs = data->io;
+		g_pRegTester = malloc(0x50);
+		memcpy(g_pRegTester, (const void *) &p16GP2XRegs[0x2880 >> 1], 0x50);	// store a big chunk of register info so we can compare it later
+	}
+#endif // GP2X_DEBUG
+
+	/* Create the pixel data and lookup tables */
+	hwdata = (struct private_yuvhwdata *)malloc(sizeof *hwdata);
+	overlay->hwdata = hwdata;
+	if ( hwdata == NULL )
+	{
+		SDL_OutOfMemory();
+		SDL_FreeYUVOverlay(overlay);
+		return(NULL);
+	}
+
+	// if YUV setup failed
+	if (!GP2X_SetupYUV(this, width, height, format, hwdata))
+	{
+		SDL_FreeYUVOverlay(overlay);
+		return(NULL);
+	}
+
+	overlay->hw_overlay = 1;
+
+	/* Set up the plane pointers */
+	overlay->pitches = hwdata->pitches;
+	overlay->pixels = hwdata->planes;
+
+	if(format == SDL_YUY2_OVERLAY)
+	{
+		overlay->planes = 1;
+
+		// the pitch will be the overlay width * 2
+		overlay->pitches[0] = overlay->w * 2;
+	}
+	else if(format == SDL_YV12_OVERLAY || format == SDL_IYUV_OVERLAY)
+	{
+		overlay->planes = 3;
+
+		overlay->pitches[0] = overlay->w * 1;
+		overlay->pitches[1] = overlay->w / 4;
+		overlay->pitches[2] = overlay->w / 4;
+	}
+
+	// start on the correct back buffer
+	overlay->pixels[0] = hwdata->YUVBuf[hwdata->uBackBuf][0];
+	overlay->pixels[1] = hwdata->YUVBuf[hwdata->uBackBuf][1];
+	overlay->pixels[1] = hwdata->YUVBuf[hwdata->uBackBuf][2];
+
+	/* We're all done.. */
+	printf("SDL_GP2X: Created YUV overlay\n");
+	return(overlay);
+}
+
+int GP2X_LockYUVOverlay(_THIS, SDL_Overlay *overlay)
+{
+	return(0);
+}
+
+void GP2X_UnlockYUVOverlay(_THIS, SDL_Overlay *overlay)
+{
+}
+
+int GP2X_DisplayYUVOverlay(_THIS, SDL_Overlay *overlay, SDL_Rect *dstrect)
+{
+	struct private_yuvhwdata *hwdata = overlay->hwdata;
+	unsigned int *uAddress = (unsigned int*) hwdata->GP2XAddr[hwdata->uBackBuf];
+	SDL_PrivateVideoData *data = this->hidden;
+	unsigned short volatile *p16GP2XRegs = data->io;
+
+	// check to see if we are using a different rectangle
+	// (This should be a faster way than doing a bunch of conditionals and comparisons)
+	if (((dstrect->w ^ hwdata->rctLast.w) | (dstrect->h ^ hwdata->rctLast.h) | (dstrect->x ^ hwdata->rctLast.x) |
+		(dstrect->y ^ hwdata->rctLast.y)) == 0)
+	{
+		// if we get here, it means that the rectangle size has not changed, so we can flip after vblank
+		GP2X_WaitVBlank(data);
+	}
+	// else we are using a different rectangle
+	else
+	{
+		Uint16 u16HScaleVal = (unsigned short)((1024 * overlay->w) / dstrect->w);
+		unsigned int uVScaleVal = (unsigned int) ((hwdata->u16PixelWidth * overlay->h) / dstrect->h);
+
+		// the boundary of the window on the right and bottom sides
+		// (-1 because 0 is the first pixel)
+		Sint16 s16Right, s16Bottom;
+		Sint16 x = dstrect->x;
+		Sint16 y = dstrect->y;
+
+#ifdef GP2X_DEBUG
+		// warn the user if this extra math is being done every frame
+		printf("SDL_GP2X: GP2X YUV Overlay is being resized. This usually should NOT happen every frame!\n");
+#endif // GP2X_DEV
+
+		// gp2x doesn't seem to handle negative coordinates
+		if (x < 0) x = 0;
+		if (y < 0) y = 0;
+
+		s16Right = x + (dstrect->w - 1);
+		s16Bottom = y + (dstrect->h - 1);
+
+		// gp2x doesn't seem like the coordinates going outside the physical boundaries
+		if (s16Right > 319)	s16Right = 319;
+		if (s16Bottom > 239) s16Bottom = 239;
+
+		if(hwdata->format != SDL_YUY2_OVERLAY){
+			// Set frame size for FDC
+			p16GP2XRegs[FDC_FRAME_SIZE] = (overlay->w / 16 - 1) + // width / 16 - 1
+											(overlay->h / 16 - 1) << 8; // height / 16 - 1
+		}
+
+		// now that we've done all the calculations we can before changing registers, wait for vblank
+		GP2X_WaitVBlank(data);
+
+		// we need to rescale now ...
+		// MLC_YUVA_TP_HSC (horizontal scale factor of Region A, top)
+		p16GP2XRegs[0x2886>>1] = u16HScaleVal;
+
+		// MLC_YUVA_TP_VSC[L/H] (vertical scale factor of Region A, top)
+		p16GP2XRegs[0x288A>>1] = (unsigned short) (uVScaleVal & 0xFFFF);
+		p16GP2XRegs[0x288C>>1] = (unsigned short) (uVScaleVal >> 16);	// this will usually be 0
+
+		// NOW SET COORDINATES
+
+		// MLC_YUVA_STX (X start coordinate of region A)
+		p16GP2XRegs[0x2896>>1]=x;
+
+		// MLC_YUVA_ENDX (X stop coordinate of region A)
+		p16GP2XRegs[0x2898>>1]=s16Right;
+
+		// MLC_YUV_TP_STY (Y start coordinate of region A top)
+		p16GP2XRegs[0x289A>>1]=y;
+
+		// MLC_YUV_TP_ENDY (Y stop coordinate of region A top, and the start of the bottom)
+		p16GP2XRegs[0x289C>>1] = s16Bottom;
+
+		// MLC_YUV_BT_ENDY (Y stop coordinate of region A bottom)
+		p16GP2XRegs[0x289E>>1] = s16Bottom;
+
+		// copy new rectangle over to rctLast so that we don't do this stuff on every single frame
+		hwdata->rctLast = *dstrect;
+	}
+
+	// NOW FLIP THE ACTUAL BUFFER
+
+	if(hwdata->format == SDL_YUY2_OVERLAY){
+		// NOTE : I am flipping the odd and even fields here because that's how rlyeh did it, but I am not sure
+		//  whether both of these need to be flipped.
+
+		// region A, odd fields
+		p16GP2XRegs[0x28A0>>1] = (uAddress[0] & 0xFFFF);
+		p16GP2XRegs[0x28A2>>1] = (uAddress[0] >> 16);
+
+		// region A, even fields
+		p16GP2XRegs[0x28A4>>1] = (uAddress[0] & 0xFFFF);
+		p16GP2XRegs[0x28A6>>1] = (uAddress[0] >> 16);
+
+	}else{
+		p16GP2XRegs[FDC_LUMA_OFFSET] = uAddress[0];
+		p16GP2XRegs[FDC_CB_OFFSET] = uAddress[1];
+		p16GP2XRegs[FDC_CR_OFFSET] = uAddress[2];
+
+		p16GP2XRegs[FDC_CNTL] |= 1; // START FDC
+	}
+
+	// change back buffer to the other buffer (can be 0 or 1, so XOR works nicely)
+	hwdata->uBackBuf ^= 1;
+
+	// update the pixel pointer to new back buffer
+	overlay->pixels[0] = hwdata->YUVBuf[hwdata->uBackBuf][0];
+	overlay->pixels[1] = hwdata->YUVBuf[hwdata->uBackBuf][1];
+	overlay->pixels[2] = hwdata->YUVBuf[hwdata->uBackBuf][2];
+
+	return(0);
+}
+
+void GP2X_FreeYUVOverlay(_THIS, SDL_Overlay *overlay)
+{
+	struct private_yuvhwdata *hwdata;
+	unsigned short volatile *p16GP2XRegs = this->hidden->io;
+
+	hwdata = overlay->hwdata;
+
+	if ( hwdata )
+	{
+		free(hwdata);
+	}
+
+	// restore our registers
+	GP2X_SaveRestoreRegs(this, 0);
+
+#ifdef GP2X_DEBUG
+	// this is a self-test precaution
+
+	// make sure that the registers were restored properly
+	assert (memcmp(g_pRegTester, (const void *) &p16GP2XRegs[0x2880 >> 1], 0x50) == 0);
+
+	free(g_pRegTester);
+#endif // GP2X_DEBUG
+
+}
+
+
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xyuv_c.h SDL-1.2.11/src/video/gp2x/SDL_gp2xyuv_c.h
--- SDL-1.2.11.orig/src/video/gp2x/SDL_gp2xyuv_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/SDL_gp2xyuv_c.h	2020-04-13 13:05:31.944199191 +0200
@@ -0,0 +1,34 @@
+/*
+    SDL - Simple DirectMedia Layer - SDL_gp2xyuv extension
+    Copyright (C) 2007 Matt Ownby
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* This is the GP2X implementation of YUV video overlays */
+
+#include "SDL_video.h"
+#include "SDL_gp2xvideo.h"
+
+extern SDL_Overlay *GP2X_CreateYUVOverlay(_THIS, int width, int height, Uint32 format, SDL_Surface *display);
+
+extern int GP2X_LockYUVOverlay(_THIS, SDL_Overlay *overlay);
+
+extern void GP2X_UnlockYUVOverlay(_THIS, SDL_Overlay *overlay);
+
+extern int GP2X_DisplayYUVOverlay(_THIS, SDL_Overlay *overlay, SDL_Rect *dstrect);
+
+extern void GP2X_FreeYUVOverlay(_THIS, SDL_Overlay *overlay);
+
diff -N -rbU5 SDL-1.2.11.orig/src/video/gp2x/tslib.h SDL-1.2.11/src/video/gp2x/tslib.h
--- SDL-1.2.11.orig/src/video/gp2x/tslib.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11/src/video/gp2x/tslib.h	2020-04-13 13:05:31.924198614 +0200
@@ -0,0 +1,94 @@
+#ifndef _TSLIB_H_
+#define _TSLIB_H_
+/*
+ *  tslib/src/tslib.h
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the LGPL.
+ *
+ * $Id: tslib.h,v 1.4 2005/02/26 01:47:23 kergoth Exp $
+ *
+ * Touch screen library interface definitions.
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#include <stdarg.h>
+#include <sys/time.h>
+
+#ifdef WIN32
+  #define TSIMPORT __declspec(dllimport)
+  #define TSEXPORT __declspec(dllexport)
+  #define TSLOCAL
+#else
+  #define TSIMPORT
+  #ifdef GCC_HASCLASSVISIBILITY
+    #define TSEXPORT __attribute__ ((visibility("default")))
+    #define TSLOCAL __attribute__ ((visibility("hidden")))
+  #else
+    #define TSEXPORT
+    #define TSLOCAL
+  #endif
+#endif
+
+#ifdef TSLIB_INTERNAL
+  #define TSAPI TSEXPORT
+#else
+  #define TSAPI TSIMPORT
+#endif // TSLIB_INTERNAL
+
+typedef struct tsdev {
+  int fd;
+} TSDEV;
+
+struct ts_sample {
+	int		x;
+	int		y;
+	unsigned int	pressure;
+};
+
+/*
+ * Close the touchscreen device, free all resources.
+ */
+TSAPI int ts_close(struct tsdev *);
+
+/*
+ * Configure the touchscreen device.
+ */
+TSAPI int ts_config(struct tsdev *);
+
+/*
+ * Change this hook to point to your custom error handling function.
+ */
+extern TSAPI int (*ts_error_fn)(const char *fmt, va_list ap);
+
+/*
+ * Returns the file descriptor in use for the touchscreen device.
+ */
+TSAPI int ts_fd(struct tsdev *);
+
+/*
+ * Load a filter/scaling module
+ */
+TSAPI int ts_load_module(struct tsdev *, const char *mod, const char *params);
+
+/*
+ * Open the touchscreen device.
+ */
+TSAPI struct tsdev *ts_open(const char *dev_name, int nonblock);
+
+/*
+ * Return a scaled touchscreen sample.
+ */
+TSAPI int ts_read(struct tsdev *, struct ts_sample *, int);
+
+/*
+ * Returns a raw, unscaled sample from the touchscreen.
+ */
+TSAPI int ts_read_raw(struct tsdev *, struct ts_sample *, int);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _TSLIB_H_ */
diff -N -rbU5 SDL-1.2.11.orig/src/video/SDL_blit_1.c SDL-1.2.11/src/video/SDL_blit_1.c
--- SDL-1.2.11.orig/src/video/SDL_blit_1.c	2020-04-13 13:02:59.475794858 +0200
+++ SDL-1.2.11/src/video/SDL_blit_1.c	2020-04-13 13:05:47.956661714 +0200
@@ -72,12 +72,33 @@
 #define LO	0
 #else /* ( SDL_BYTEORDER == SDL_BIG_ENDIAN ) */
 #define HI	0
 #define LO	1
 #endif
+
+
+/* GP2X ARM ASM Blit 1to2 */
+#if defined(SDL_VIDEO_DRIVER_GP2X)
+	void Blit1to2ARM(Uint8 *src, int srcskip,
+		Uint8 *dst, int dstskip,
+		int width, int height,
+		Uint16 *map);
+#endif
+
 static void Blit1to2(SDL_BlitInfo *info)
 {
+/* GP2X ARM ASM Blit 1to2 */
+#if defined(SDL_VIDEO_DRIVER_GP2X)
+	Blit1to2ARM(info->s_pixels,
+		info->s_skip,
+		info->d_pixels,
+		info->d_skip,
+		info->d_width,
+		info->d_height,
+		(Uint16 *)info->table);
+#else
+
 #ifndef USE_DUFFS_LOOP
 	int c;
 #endif
 	int width, height;
 	Uint8 *src, *dst;
@@ -180,10 +201,11 @@
 			src += srcskip;
 			dst += dstskip;
 		}
 	}
 #endif /* USE_DUFFS_LOOP */
+#endif /* SDL_VIDEO_DRIVER_GP2X */
 }
 static void Blit1to3(SDL_BlitInfo *info)
 {
 #ifndef USE_DUFFS_LOOP
 	int c;
diff -N -rbU5 SDL-1.2.11.orig/src/video/SDL_sysvideo.h SDL-1.2.11/src/video/SDL_sysvideo.h
--- SDL-1.2.11.orig/src/video/SDL_sysvideo.h	2020-04-13 13:02:59.475794858 +0200
+++ SDL-1.2.11/src/video/SDL_sysvideo.h	2020-04-13 13:06:02.372078102 +0200
@@ -402,10 +402,13 @@
 extern VideoBootStrap OS2FSLib_bootstrap;
 #endif
 #if SDL_VIDEO_DRIVER_AALIB
 extern VideoBootStrap AALIB_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_GP2X
+extern VideoBootStrap GP2X_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
 
 /* This is the current video device */
diff -N -rbU5 SDL-1.2.11.orig/src/video/SDL_video.c SDL-1.2.11/src/video/SDL_video.c
--- SDL-1.2.11.orig/src/video/SDL_video.c	2020-04-13 13:02:59.475794858 +0200
+++ SDL-1.2.11/src/video/SDL_video.c	2020-04-13 13:06:08.036241707 +0200
@@ -118,10 +118,13 @@
 	&OS2FSLib_bootstrap,
 #endif
 #if SDL_VIDEO_DRIVER_AALIB
 	&AALIB_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_GP2X
+	&GP2X_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
 	NULL
 };
